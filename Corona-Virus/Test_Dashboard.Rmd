---
title: "Coronavirus SARS-CoV-2 / Covid-19"
author: "Wolfgang Vollmer"
date: '`r Sys.Date()`'
cite-color: "green"
bibliography: References_Corona.bib
output:
   flexdashboard::flex_dashboard:
   vertical_layout: scroll
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, echo = FALSE, warning = FALSE,      
                      message = FALSE, fig.width = 7, fig.asp = 0.618)

library(flexdashboard)

# output:
#    flexdashboard::flex_dashboard:
#       vertical_layout: scroll
```

```{r}
# Reference Style Links and Images
# Links

# A [linked phrase][id]. 
# 
# At the bottom of the document:
# 
# [id]: http://example.com/ "Title"
# 
# link-citations: yes
```



```{r initialization, eval = TRUE, include = FALSE}

################################################################################
##                                                                            ##
## Corona Virus -                                                             ##
##       Analyze Time Series of Confirmed, Death and Recovered Cases          ##
##                                                                            ##
##                                              Wolfgang Vollmer, March 2020  ##
##                                                                            ##
################################################################################

######  variables clean up, library() and	source() statements
# setwd("D:/Wolfgang/Programs-R/R-WeatherAnalysis")
setwd("D:/Wolfgang/Programs-R/R-TimeSeriesAnalysis/Corona-Virus")
rm(list=ls()) # deletes all existing objects / variables !!
Prog.Start <- Sys.time()

library(tidyverse)
library(magrittr)
library(lubridate)
library(fpp3)  # tsibble, tsibbledata, fable, and feasts packages & some tidyverse
library(stlplus) # Enhanced Seasonal Decomposition of Time Series by Loess
library(DT)      # R interface to the JavaScript library DataTables
library(rlang)
library(gridExtra)

library(janitor)
library(highcharter)

library(dygraphs)  # R interface to the dygraphs JavaScript charting library

######  Plot and util functions
source("./ggts_corona.R") # ggplot2 functions for time series plots
# source("./../uts_TimeSeries.R")  # utility functions for time series
# source("./../ggts_TimeSeries.R") # ggplot2 functions for time series plots

theme_replace(
  plot.title = element_text(
    hjust = 0.5, face = "bold.italic", color = "darkcyan", size = 12),
  plot.subtitle = element_text(
    hjust = 0.5, face = "italic", color = "darkcyan")
)
x_axis_theme <- element_text(size = 14)
```


```{r settings}

compare_countries <- c("Austria", "France", "Germany", "Italy", "India",
                       "South Korea", "Spain",  "United States of America")
countries <- c("China", compare_countries)
countries_exp_growth <- c("World", "China", "Germany", "Italy", 
                       "South Korea", "Spain",  "United States of America")
country_select <- "Germany"

reg_range <- 7   # important - no Cases value = 0 are llowed => log(0) = inf !
# changed from 9 -> 7 days, 
# but whole week is necessary to get rid of weekly fluctuations
forcast_range <- 14  # 14days forecast => unclass(last_date + 1 + forcast_range -1)

```


```{r read data and settings}

corona_country <- readRDS("corona_country.RDS")
corona_population <- readRDS("corona_population.RDS")

corona_country_wide <- corona_country %>% 
  pivot_wider(names_from = Case_Type, 
              values_from = c(Cases, Daily_Cases)) %>% 
  rename(Confirmed = Cases_Confirmed,
         Deaths = Cases_Deaths,
         Daily_Confirmed = Daily_Cases_Confirmed,
         Daily_Deaths = Daily_Cases_Deaths)

corona_population_wide <- corona_population %>% 
  select(-Cases, -Daily_Cases, -Population) %>% 
  pivot_wider(names_from = Case_Type, 
              values_from = c(Cases_100k, Daily_Cases_100k)) %>% 
  rename(Conf_100k = Cases_100k_Confirmed,
         Deaths_100k = Cases_100k_Deaths,
         Daily_Conf_100k = Daily_Cases_100k_Confirmed,
         Daily_Deaths_100k = Daily_Cases_100k_Deaths) 

first_date <- min(corona_country$Date)
last_date <- max(corona_country$Date)

corona_country_last <- corona_country %>%  filter(Date == last_date)
corona_population_last <- corona_population %>% filter(Date == last_date)

# corona_tsbl <- corona_country  %>%
#   as_tsibble(index = Date, key = c(Country, Case_Type))

corona_tsbl <- corona_population  %>%
  as_tsibble(index = Date, key = c(Country, Case_Type))

```


```{r test slice views, eval = FALSE}

country_select <- "World"
n_days <- 9
last_n_days <- last_date - n_days + 1  

View(corona %>% 
       filter(Country == country_select & Date >= last_n_days) %>% 
       arrange(Case_Type)
       )
selection <- corona %>% filter(Country == country_select & Date >= last_n_days)
(slice(selection, n() -4:0))

View(corona_country %>% 
       filter(Country == country_select & Date >= last_n_days) %>% 
       arrange(Case_Type)
       )
selection <- corona_country %>% filter(Country == country_select & Date >= last_n_days)
(slice(selection, n() -4:0))

```


World Map
=====================================  

***
***

**World Map with Confirmed and Death Cases**  

Here we are [see @Wikipedia2019] and [see @CIA2020] otherwise [@JHU2020a] or 
[@JHU2020]


### Total Confirmed for each Country

```{r World Map Confirmed, eval=FALSE}

```

### Total Deaths for each Country

```{r World Map Deaths, eval=FALSE}

```


Bar Chart {data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Column {data-width=400}
-------------------------------------

### Bar Chart Confirmed

```{r Top Ten Bar Chart Confirmed}


```

### Bar Chart Table Deaths

```{r Top Ten Bar Chart Deaths}

```


Column
-------------------------------------

### Data Table of Confirmed and Deaths - Cumulated and Daily Cases


```{r print datatable in wide format}

```


Bar Chart / Inhabitants {data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Column
-------------------------------------
### Bar Chart Confirmed per 100,000 Inhabitants

```{r Top 20 Bar Chart Population Confirmed}


```

Column
-------------------------------------

### Bar Chart Table Deaths / 100k Population

```{r Top 20 Bar Chart Population Deaths}


```


Cumulated and Daily Trend {data-orientation=rows}
=====================================

***
***


```{r}
country <- "World"
```


**Cumulated and Daily Cases over Time**  

Row {data-height=400}
------------------------------------

### `r country`

```{r  Time Series Diagram Worldwide}

ggts_trend_daily(corona_country %>% filter(Country == country), country)

i <- 1

```


Row {.tabset .tabset-fade}
------------------------------------

**Selected Countries**

### `r countries[i]` 

```{r  Time Series Diagram countries 1}
country <- countries[i]
ggts_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

Row {.tabset .tabset-fade}
------------------------------------

**Selected Countries - Cumulated Cases / Daily Changes over Time**

### `r countries[i]` 

```{r  Time Series Diagram countries 2, eval = FALSE}
country <- countries[i]
ggts_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### Germany - Confirmed and Deaths

```{r  dygraph_plot all, eval = TRUE}


```

### Germany - Deaths

```{r  Time Series Deaths dygraph_plot, eval = FALSE}
country <- "Germany"
case_type <- "Deaths"

dygraph_plot(corona_country, country, case_type, last_date) 
```


Exponential Growth {data-navmenu="Exp Linear Growth"}
=====================================

***
***

Column {data-width=400}
------------------------------------  

### Estimation speed of spread of the Coronavirus with Linear Regression

**Exponential Growth and Doubling Time $T$**

### `r country_select` - Trend with Forecast on a linear scale


```{r corona cumulated tsibble reg_range}

# provide tsb of reg_range/last 7 days for linear regression of log data
corona_tsbl_reg_range <- corona_tsbl %>% 
  ungroup() %>% 
  group_by(Case_Type) %>% 
  filter(Country %in% c("World", compare_countries) & 
           Date >= last_date - reg_range + 1 &
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)


```

```{r corona daily tsibble reg_range}

daily_reg_range <- 21  # one week is to short, confidence level to large !!

# provide tsb of reg_range/last 7 days for linear regression of daily data
corona_daily_reg_range_tsbl <- corona_tsbl %>% 
  ungroup() %>% 
  group_by(Case_Type) %>% 
  filter(Country %in% c("World", compare_countries) & 
           Date >= last_date - daily_reg_range + 1 &
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Daily_Cases)


```


```{r example, fig.width = 10, fig.height = 5}

fit_corona <- corona_tsbl_reg_range %>% ungroup() %>% 
  group_by(Case_Type) %>% 
  model(TSLM(log(Cases) ~ Date)) 
fc_corona <- fit_corona %>% fabletools::forecast(h = "14 days") 

fc_corona %>%  
  filter(Country == country_select) %>% 
  autoplot(corona_tsbl_reg_range) +
  ggtitle(paste(country_select, "- Cases and 14-days Forecast on linear y-scale"),
            subtitle = "Example shows the extreme fast increase on linear scale") +
  labs(x = "Days") +
  # scale_y_log10() +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```



### Forecast Plot - next `r forcast_range` days {data-height=150}



Column {data-width=600}
------------------------------------ 

### Comparison Exponential Growth 


```{r plot log10scale selected Country}

```

### Germany - Example plot with ~linear slope on a log10 scale

```{r  Plot with Linear Regression}

```

Exponential Growth since Jan {data-navmenu="Exp Linear Growth"}
=====================================

***
***


Column {data-width=200}
-------------------------------------

### Exponential Growth Evaluation


Column
-------------------------------------

### Virus Spread since mid of January 


```{r plot log10scale w/o date filter, fig.width = 7, fig.asp = 1.5}


```

Linear Growth {data-navmenu="Exp Linear Growth"}
=====================================

***
***


```{r cumulated forecast exp growth}

fit_cum_corona <- corona_tsbl_reg_range %>% ungroup() %>% 
  group_by(Case_Type) %>% 
  model(Exp_Growth = TSLM(log(Cases) ~ Date),
        Linear_Growth = TSLM(Cases ~ Date)) 

fc_cum_corona <- fit_cum_corona %>% fabletools::forecast(h = "7 days") 

corona_cum_daily_reg_range_tsbl <- corona_tsbl %>% 
  ungroup() %>% 
  group_by(Case_Type) %>% 
  filter(Country %in% c("World", compare_countries) & 
           Date >= last_date - daily_reg_range + 1 &
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

fc_cum_corona %>%  
  filter(Country == country_select) %>% 
  autoplot(corona_cum_daily_reg_range_tsbl) +
  ggtitle(paste(country_select, "- Cases and 7-days Forecast (based on regression of past week)"),
            subtitle = "Increase of Cumulated Cases with assumption of exponential growth") +
  labs(x = "Days") +
  # scale_y_log10() +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```

Column
-------------------------------------

```{r daily forecast linear model}

fit_daily_corona <- corona_daily_reg_range_tsbl %>% ungroup() %>% 
  group_by(Case_Type) %>% 
    model(Exp_Growth = TSLM(log(Daily_Cases) ~ Date),
        Linear_Growth = TSLM(Daily_Cases ~ Date)) 
  # model(TSLM(Daily_Cases ~ Date)) 
fc_daily_corona <- fit_daily_corona %>% fabletools::forecast(h = "7 days") 

fc_daily_corona %>%  
  filter(Country == country_select) %>% 
  autoplot(corona_daily_reg_range_tsbl) +
  ggtitle(paste(country_select, "- Daily Cases and 7-days Forecast (based on regression of past 3 weeks)"),
            subtitle = "Fluctuations of daily cases requires regression over 3 weeks") +
  labs(x = "Days") +
  # scale_y_log10() +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```



Doubling Time / Forecast {data-navmenu="Forecast"}
=====================================

***
***

Column {data-width=500}
-------------------------------------

**Doubling Time and Forecast**

Here we are [see @Wikipedia2020] and [see @CIA2020] otherwise [@JHU2020a] or 
[@JHU2020] 

Also [@RKI2020a] or [@RKI2020]

The forecasted cases for the next 14 days are calculated 'only' from the
linear regression of the logarithmic data and are not considering any effects of 
measures in place. In addition data inaccuracies are not taken into account, 
especially relevant for the confirmed cases. 

Therefore the 14 days forecast is only an indication for the direction of an 
unchecked exponentiell growth.

```{r calculate forecast with beta_0 and beta_1, eval = TRUE}

coefs <- tidy(fit_corona) %>% 
  group_by(Country, Case_Type) %>% 
  mutate(T_doubling = (log(2) /estimate))

forecast_country <- coefs %>% 
  pivot_wider(id_cols = c(Country, Case_Type), 
              names_from = term, 
              values_from = estimate) %>% 
  rename(beta_0 = `(Intercept)`,
         beta_1 = Date) %>% 
  mutate(T_doubling = (log(2) / beta_1),
         FC_next_day = exp(beta_0 + unclass(last_date + 1) * beta_1),
         FC_14days = exp(beta_0 + unclass(last_date + 1 + forcast_range-1) 
                              * beta_1)) 

forecast_table <- forecast_country %>%
  filter(Case_Type != "Recovered") %>% 
  group_by(Country, Case_Type) %>%
  summarise(T_doubling = sum(T_doubling, na.rm = TRUE),
            FC_next_day = sum(FC_next_day, na.rm = TRUE),
            FC_14days = sum(FC_14days, na.rm = TRUE)) %>% 
  arrange(Case_Type)

countries_last_day <- corona_country %>% 
  filter(Country %in% c(compare_countries, "World") & 
           Date == last_date &
           Case_Type != "Recovered") %>%
  rename(last_day = Cases) %>% 
  arrange(Case_Type) %>% 
  select(Country, Case_Type, last_day)

forecast_table <- left_join(forecast_table, countries_last_day) %>% 
  select(Country, Case_Type, T_doubling, last_day, 
         FC_next_day, FC_14days)

knitr::kable(forecast_table,  digits = c(0, 0, 1, 0, 0),
             format.args = list(big.mark = "'"),
             caption = 
             "Forecast (FC) with linear regression: Doubling Time (days), 
             Forecasted cases tomorrow and  Forecasted cases in 14 days")

# check
# corona %>%  filter(Country %in% compare_countries, Date >= last_date + 1 - 1) 

```

Column
-----------------------------------------------------------------------  

### Check of Forecast Accuracy {data-height=400}

The forecast accuracy is checked by using the forecast method for the nine days
before the past three days (*training data*). Subsequent forecasting of the 
past three days enables comparison with the real data of these days (*test data*).

The comparison is also an early indicator if the *exponential growth* is declining. However, possible changes in underreporting
(in particular the proportion confirmed / actually infected) requires careful interpretation.

For doubling periods in the order of infectivity (RKI assumption: $\sim9-10$
days, with great uncertainty), see [@RKI Modelling Paper] and Here we are [see @expgrowth]
https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Modellierung_Deutschland.pdf?__blob=publicationFile), we no longer have exponential growth. Since the "old" infected cases are 
no longer infectious after these periods and we then have a constant infection rate with  basic reproduction number $R_0 \sim 1$.

Instead, we have "only" linear growth of the cumulative *Confimred Cases* and 
the *Daily Confirmed Cases* remain more or less constant or even decrease.

However, the basic reproduction number $R_0$ is a product of the average number of contacts of an infectious person per day, the probability of transmission upon contacts and the average number of days infected people are infectious. 
With the current uncertainty of the average duration of the infectivity duration, $R_0$ can therefore be estimated from the doubling time only to a very limited extent.
See also: https://cmmid.github.io/topics/covid19/current-patterns-transmission/global-time-varying-transmission

### Germany - Forecast Accuracy for past three days {data-height=300}

```{r forecasts accuracy, fig.width = 10, fig.height = 5, eval = FALSE}
# Note: as long as zero deaths are in this time range log(0) will go to infinity,
# therefore still no linear regression possible.

training_data_start <- 12 #reg_range + 3  # minus 12 days
training_data_end   <- 3  #reg_range - 6  # minus  3 days
# total = training + test_data => 
#    Date >= last_date + 1 - training_data_start = last 3 days

corona_tsbl_train <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% country_select & 
           Date >= last_date + 1 - training_data_start &
           Date < last_date + 1 - training_data_end &
           Case_Type != "Recovered") %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

corona_tsbl_total <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% country_select  & 
           Date >= last_date + 1 -  training_data_start &
           Case_Type != "Recovered") %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

fit_corona_train <- corona_tsbl_train %>% ungroup() %>% 
  group_by(Case_Type) %>% 
  model(TSLM(log(Cases) ~ Date)) 
fc_corona_train <- fit_corona_train %>% 
  fabletools::forecast(h = "3 days") 

# forecasts accuracy
# for evaluating accuracy on forecasts to be provided:
# - a complete dataset that includes the future data and 
# - data used to train the model.

# level = prediction interval in % or NULL
fc_corona_train %>%
  filter(Country == country_select) %>% 
  autoplot(corona_tsbl_total) +
  labs(x = "Year",
       title = paste(country_select, "Forecast Accuracy"),
       subtitle = "Forecast (blue line) vs. Data (black line)") +
    facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left") +
  scale_x_date(date_labels = "%b %d", date_breaks = "2 days") +
  ggtitle("Forecast Accuracy")

```

Forecast {data-navmenu="Forecast"}
=====================================

***
***

Column {data-width=400}
-------------------------------------

### Forecasting with lagged Predictors


Column
-------------------------------------

### Forecasting Daily Deaths with lagged Daily Confirmed Cases


```{r forecast for selected countries and lags}

# avg_days_to_confirmed  # Incubation period ~ 5-6 days; Hospitalisation + 4 days
# avg_days_to_death      # death     ~ after 21 days
# lag_n                  # avg_days_to_death - (period infected to confirmed)
# case_fatality_rate     # proportion of deaths / number of people diagnosed
#                                                                   (Confirmed)

lag_germany <- 12
lag_italy <- 12
lag_spain <- 10

countries_to_forecast <- c("Germany", "Italy", "Spain")

countries_fc_param <-
  tibble(Country = countries_to_forecast,
       confirmed_to_death = c(lag_germany, lag_italy , lag_spain),
       infected_to_death     = 21,
       # case_fatality_rate = c(0.06, 0.25, 0.3)) %>% 
       case_fatality_rate = c(0.05, 0.25, 0.25)) %>% 
  mutate(infected_to_confirmed = infected_to_death  - confirmed_to_death)

        
```

```{r Deaths compared lagged, eval = TRUE, fig.width = 6, fig.asp = 0.618}

for (country in countries_fc_param$Country) {
data <- corona_country_wide %>% 
  filter(Country == country)


lag_n <- filter(countries_fc_param, Country == country)$confirmed_to_death
case_fatality_rate <- 
  filter(countries_fc_param, Country == country)$case_fatality_rate 

data %<>%   
  mutate(Confirmed_lag_n = case_fatality_rate * lag(Confirmed, lag_n)) %>%
  dplyr::select(Country, Date, Confirmed, Confirmed_lag_n, Deaths) %>% 
  pivot_longer(cols = c(-Country, -Date), 
               names_to = "Case_Type",
               values_to = "Cases")

data %<>% filter(Case_Type != "Confirmed" & Date >= last_date - 27)

plot <- ggplot(data, aes(Date, Cases, col = Case_Type)) +
  geom_point(size = 1.5, na.rm = TRUE) +
  geom_line(na.rm = TRUE) +  
  theme(legend.position = "none")  +
  labs(title = paste(country, 
                     "- Cumlated Deaths compared to lagged Confirmed (past 4 weeks)"), 
       subtitle = paste("lagged by", lag_n, "Days and CFR =", case_fatality_rate)) + 
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") 

print(plot)
}
```

```{r Italy data correction, eval = FALSE}
### corrrection for Italy on "2020-03-12" required, cases  are 0 => no usefull fit
#  Country Date       Case_Type Cases Daily_Cases
#   <chr>   <date>     <chr>     <dbl>       <dbl>
# 1 Italy   2020-03-12 Confirmed 12462           0
# 2 Italy   2020-03-12 Deaths      827           0
# 3 Italy   2020-03-13 Confirmed 17660        5198
# 4 Italy   2020-03-13 Deaths     1266         439

corona_replace_rows <- corona_country %>%
  filter(Country == "Italy" &
           Date >= date("2020-03-12") &
           Date <= date("2020-03-13")
         ) %>%
  mutate(Daily_Cases = mean(Daily_Cases))

# save_corona_country <- corona_country
# test <- corona_country %>% 
#   filter(Country != "Italy" |
#            (Date != date("2020-03-12") & Date != date("2020-03-13")))
# test %>%
#   filter(Country == "Italy" &
#            Date >= date("2020-03-07") &
#            Date <= date("2020-03-14") )

corona_country <- bind_rows(corona_replace_rows,
          corona_country %>% filter(Country != "Italy" |
                   (Date != date("2020-03-12") & Date != date("2020-03-13")))
          )

corona_tsbl <- corona_country  %>%
  as_tsibble(index = Date, key = c(Country, Case_Type))
#######

```

```{r}
# identify "best" lag_day with lowest AICc 

lag_days <-  max(countries_fc_param$confirmed_to_death)
lag_range <- lag_days + 21
country <- countries_to_forecast[1]


corona_tsbl_lag_range <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% countries_to_forecast &
           Case_Type != "Recovered" &
           Date >= last_date - lag_range) %>% 
  dplyr::select(Date, Country, Case_Type, Daily_Cases) %>% 
  group_by(Country)

```


```{r}
## wide format to get Daily Deaths as function of Daily Confirmed Cases
corona_tsbl_lag_range_wide <- corona_tsbl_lag_range %>%   
  pivot_wider(id_cols = c(Country, Date), 
              names_from = Case_Type, 
              values_from = Daily_Cases) %>% 
  as_tsibble(index = Date, key = c(Country))
  
no_values <- nrow(corona_tsbl_lag_range_wide %>% filter(Country == country)) 

```


```{r corona tsibble identify TSLM model, eval = FALSE}

# model ~ 0 + => w/o intercept
fit_tslm_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>% 
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_m3 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 3)),
        lag_m2 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 2)),
        lag_m1 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 1)),
        lag_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_1 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 1)),
        lag_2 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 2)),
        lag_3 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 3)),

  )
# identify lowest AICc value for best fit
glance(fit_tslm_lag) %>% arrange(AICc)

# Residual accuracy - can be computed directly from models as the 
# one-step-ahead fitted residuals are available  
# identify lowest RMSE, MAE value for best fit
fit_tslm_lag %>% accuracy() %>% arrange(RMSE, MAE) 

cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_tslm_lag) %>%
  features(.resid, ljung_box, lag = 4) %>% arrange(desc(lb_pvalue))

```



```{r corona tsibble TSLM best fit, eval = FALSE, fig.width = 5, fig.asp = 0.618}

# model ~ 0 + => w/o intercept
fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)))
# tidy(fit_best)

# provide tibble with Country fatality_rate lag_n
fit_best_coefs <- tidy(fit_best) %>% 
  pivot_wider(id_cols = c(Country), 
              names_from = term, 
              values_from = estimate) %>% 
    rename(fatality_rate = `lag(Confirmed, lag_days)`) %>% 
  mutate(lag_n = lag_days)

fit_best  %>%  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ ACF Correlogram and Histogram"),
       subtitle = paste("Model:", coef(fit_best)$.model, "lag_days:", lag_days))

## provide tibble with Country Date Confirmed Deaths Deaths_calc
# calculate beta_0 * confirmed (note: still to be lagged!)

#  provide tsibble with same tsibble structure and lag_days * new rows w7 NA NA
#   and filling the key-index pair (new next dates, w/ new_data())
corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  new_data(lag_days, keep_all = TRUE) 
corona_deaths_of_confirmed_tbl <- bind_rows(as_tibble(corona_tsbl_lag_range_wide), 
          as_tibble(corona_deaths_of_confirmed)) %>%  
  filter(Country == country) %>% 
  mutate(Deaths_calc = fit_best_coefs$fatality_rate * lag(Confirmed, lag_days))

## plot Daily Deaths plus FC of model(TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_best %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  filter(Country == country)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Daily Deaths based on Confirmed Cases", 
          subtitle = 
            paste(filter(fit_best_coefs, Country == country)$Country, 
                  "- Confirmed Cases lagged by", 
                  filter(fit_best_coefs, Country == country)$lag_n, 
                  "days, ", 
                  "Fatality Rate:",
                  round(filter(fit_best_coefs, Country == country)$fatality_rate, 
                    digits = 3)))
```




```{r corona tsibble identify ARIMA model, eval = FALSE}

# identify "best" lag_day with lowest AICc 
lag_days_1 <- lag_days + 1
lag_days_2 <- lag_days + 2

# model ~ 0 + => w/o intercept
fit_arima_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>%
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_A_0 = ARIMA(Deaths ~ 0 + pdq(d = 0) + lag(Confirmed, lag_days)),
        lag_T_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_A_1 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1)),
        lag_A_2_0 = ARIMA(Deaths ~ 0 + pdq(p=0, d = 0, q = 0) + 
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_T_2 = TSLM(Deaths ~ 0 +
                         lag(Confirmed, lag_days - 2) +
                         lag(Confirmed, lag_days - 1) +
                         lag(Confirmed, lag_days) +
                         lag(Confirmed, lag_days + 1) +
                         lag(Confirmed, lag_days + 2)),
  )
# identify lowest AICc value for best fit
glance(fit_arima_lag) %>% arrange(AICc)
# tidy(fit_arima_lag)
coef(fit_arima_lag)
# report(fit_arima_lag)

# Residual accuracy - can be computed directly from models as the 
# one-step-ahead fitted residuals are available  
# identify lowest RMSE, MAE value for best fit
fit_arima_lag %>% accuracy() %>% arrange(RMSE, MAE) 

cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_arima_lag) %>%
  features(.resid, ljung_box, lag = 10) %>% arrange(desc(lb_pvalue))


corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>%  
  new_data(lag_days, keep_all = TRUE)

## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_arima_lag %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Accuracy", 
          subtitle = paste("TSLM and ARIMA-Models, lag Confirmed:", lag_days, "days"))

as.character(format(fit_arima_lag$lag_A_0))
as.character(format(fit_arima_lag$lag_A_1))
as.character(format(fit_arima_lag$lag_A_2))
as.character(format(fit_arima_lag$lag_A_2_0))


fit_selected <- fit_arima_lag %>% 
  select(Country, lag_A_0, lag_A_1, lag_A_2, lag_A_2_0)
  # select(Country, lag_A_0, lag_T_0, lag_A_2, lag_T_2)

fit_selected %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Accuracy", 
          subtitle = paste("TSLM and ARIMA-Models, lag Confirmed:", lag_days, "days"))
```

```{r corona tsibble compare TSLM ARIMA model, eval = FALSE}
country <- "Germany"
lag_days <- 12

fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +  # pdq(p = 0, d = 0, q = 0) + 
                          lag(Confirmed, lag_days - 2) + 
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)))
coef(fit_best)
report(fit_best)
# fit_best %>% accuracy() %>% arrange(RMSE, MAE) 

# ljung_box Test: dof - Degrees of freedom of the fitted model 
#                           (useful if x is a series of residuals)
cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_best) %>%
  features(.resid, ljung_box, lag = 10) %>% arrange(desc(lb_pvalue))

filter(residuals(fit_best)) %>%
  ACF(.resid, lag.max = 36) %>% autoplot() +
  labs(title = "ACF - Forecast Residuals", subtitle ="ets")
filter(residuals(fit_best)) %>%
  PACF(.resid, lag.max = 36) %>% autoplot() +
  labs(title = "PACF - Forecast Residuals", subtitle ="ets")

# not working !
# fit_best  %>% 
#   gg_tsresiduals(plot_type = "partial") +
#   labs(title = paste(country, "-  Forecast Residuals w/ Correlogram and PACF"),
#        subtitle = paste("Model: ", coef(fit_best)$.model[1], "lag_days:", lag_days))

country_table_new <- c(Country = country, 
                       lag_Confirmed = lag_days, 
                       CFR = as.numeric(
                         round(coef(fit_best) %>%  
                                 filter(term %in% lm_term) %>%
                                 summarise(CFR = sum(estimate)), digits = 3))
)

country_table_new

fit_best  %>% 
  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ Correlogram and Histogram"),
       subtitle = paste("Model: ", coef(fit_best)$.model[1], "lag_days:", lag_days))

```




```{r corona tsibble ARIMA lag_range, fig.width = 5, fig.asp = 1.2, eval = FALSE}


# model ~ 0 + => w/o intercept
# fit_best <- corona_tsbl_lag_range_wide %>%
#   # filter(Country == country) %>%
#   model(ARIMA(Deaths ~ 0 + pdq(d = 0) +
#                           lag(Confirmed, lag_days - 2) +
#                           lag(Confirmed, lag_days - 1) +
#                           lag(Confirmed, lag_days) +
#                           lag(Confirmed, lag_days + 1) +
#                           lag(Confirmed, lag_days + 2)))
# tidy(fit_best)
# coef(fit_best)
# glance(fit_best)
# report(fit_best)

# provide tibble with Country fatality_rate lag_n
# fit_best_coefs <- tidy(fit_best) %>% 
#   pivot_wider(id_cols = c(Country), 
#               names_from = term, 
#               values_from = estimate) %>% 
#     rename(fatality_rate = `lag(Confirmed, lag_days)`) %>% 
#   mutate(lag_n = lag_days)


# provide tsibble with same tsibble structure and lag_days * new rows w/ NA NA
#  and filling the key-index pair (new next dates, w/ new_data())
corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>%
  new_data(lag_days, keep_all = TRUE)


## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_best %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Daily Deaths based on Confirmed Cases", 
          subtitle = paste("ARIMA-Model, lag Confirmed:", lag_days, "days"))



             

```

old below  #######################################



```{r plot facet daily confirmed and daily deaths, eval = FALSE}

corona_tsbl_lag_range %>% 
  filter(Country == country) %>% 
  ggplot(aes(x = Date, y = Daily_Cases)) +
  geom_line() +
  facet_grid(vars(Case_Type), scales = "free_y") +
  labs(x = "Day", y = NULL,
       title = paste(country, "- Daily Confirmed and Death Cases"),
       subtitle = "w/o lagging and w/o fatality factor")

```

```{r ksfd, , eval = FALSE}
## wide format to get Daily Deaths as function of Daily Confirmed Cases
corona_tsbl_lag_range_wide <- corona_tsbl_lag_range %>%   
  pivot_wider(id_cols = c(Country, Date), 
              names_from = Case_Type, 
              values_from = Daily_Cases) %>% 
  as_tsibble(index = Date, key = c(Country))
  
no_values <- nrow(corona_tsbl_lag_range_wide %>% filter(Country == country)) 

```


```{r corona tsibble identify ARIMA TSLM model, eval = FALSE}

# identify "best" lag_day with lowest AICc 
lag_days_1 <- lag_days + 1
lag_days_2 <- lag_days + 2

# model ~ 0 + => w/o intercept
fit_arima_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>%
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_A_0 = ARIMA(Deaths ~ 0 + pdq(d = 0) + lag(Confirmed, lag_days)),
        lag_T_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_A_1 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1)),
        lag_T_1 = TSLM(Deaths ~ 0 +
                         lag(Confirmed, lag_days - 1) +
                         lag(Confirmed, lag_days) +
                         lag(Confirmed, lag_days + 1)),
        lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_T_2 = TSLM(Deaths ~ 0 +
                         lag(Confirmed, lag_days - 2) +
                         lag(Confirmed, lag_days - 1) +
                         lag(Confirmed, lag_days) +
                         lag(Confirmed, lag_days + 1) +
                         lag(Confirmed, lag_days + 2)),
  )

fit_arima_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>%
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_A_0 = ARIMA(Deaths ~ 0 + pdq(d = 0) + lag(Confirmed, lag_days)),
        lag_T_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_A_1 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1)),
        lag_A_2_0 = ARIMA(Deaths ~ 0 + pdq(p=0, d = 0, q = 0) + 
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_T_2 = TSLM(Deaths ~ 0 +
                         lag(Confirmed, lag_days - 2) +
                         lag(Confirmed, lag_days - 1) +
                         lag(Confirmed, lag_days) +
                         lag(Confirmed, lag_days + 1) +
                         lag(Confirmed, lag_days + 2)),
  )

# identify lowest AICc value for best fit
glance(fit_arima_lag) %>% arrange(AICc)
tidy(fit_arima_lag)
coef(fit_arima_lag)
# report(fit_arima_lag)

# Residual accuracy - can be computed directly from models as the 
# one-step-ahead fitted residuals are available  
# identify lowest RMSE, MAE value for best fit
fit_arima_lag %>% accuracy() %>% arrange(RMSE, MAE) 

cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_arima_lag) %>%
  features(.resid, ljung_box, lag = 10) %>% arrange(desc(lb_pvalue))


corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>%  
  new_data(lag_days, keep_all = TRUE)

## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_arima_lag %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Accuracy", 
          subtitle = paste("TSLM and ARIMA-Models, lag Confirmed:", lag_days, "days"))


fit_selected <- fit_arima_lag %>% 
  # select(Country, lag_A_0, lag_A_1, lag_A_2)
  select(Country, lag_A_0, lag_T_0, lag_A_2, lag_T_2)

fit_selected %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Accuracy", 
          subtitle = paste("TSLM and ARIMA-Models, lag Confirmed:", lag_days, "days"))
```

```{r old corona tsibble compare TSLM ARIMA model, eval = FALSE}

fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +  # pdq(p = 0, d = 0, q = 0) + 
                          lag(Confirmed, lag_days - 2) + 
                          lag(Confirmed, lag_days- 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days+ 1) +
                          lag(Confirmed, lag_days + 2)))
coef(fit_best)
report(fit_best)
fit_best %>% accuracy() %>% arrange(RMSE, MAE) 

# ljung_box Test: dof - Degrees of freedom of the fitted model 
#                           (useful if x is a series of residuals)
cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_best) %>%
  features(.resid, ljung_box, lag = 10) %>% arrange(desc(lb_pvalue))

filter(residuals(fit_best)) %>%
  ACF(.resid, lag.max = 36) %>% autoplot() +
  labs(title = "ACF - Forecast Residuals", subtitle ="ets")
filter(residuals(fit_best)) %>%
  PACF(.resid, lag.max = 36) %>% autoplot() +
  labs(title = "PACF - Forecast Residuals", subtitle ="ets")

# not working !
# fit_best  %>% 
#   gg_tsresiduals(plot_type = "partial") +
#   labs(title = paste(country, "-  Forecast Residuals w/ Correlogram and PACF"),
#        subtitle = paste("Model: ", coef(fit_best)$.model[1], "lag_days:", lag_days))

fit_best  %>% 
  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ Correlogram and Histogram"),
       subtitle = paste("Model: ", coef(fit_best)$.model[1], "lag_days:", lag_days))

```


```{r old corona tsibble identify TSLM model, eval = FALSE}

# model ~ 0 + => w/o intercept
fit_tslm_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>% 
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_m3 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 3)),
        lag_m2 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 2)),
        lag_m1 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 1)),
        lag_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_1 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 1)),
        lag_2 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 2)),
        lag_3 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 3)),

  )
# identify lowest AICc value for best fit
glance(fit_tslm_lag) %>% arrange(AICc)

# Residual accuracy - can be computed directly from models as the 
# one-step-ahead fitted residuals are available  
# identify lowest RMSE, MAE value for best fit
fit_tslm_lag %>% accuracy() %>% arrange(RMSE, MAE) 

cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_tslm_lag) %>%
  features(.resid, ljung_box, lag = 4) %>% arrange(desc(lb_pvalue))

```


```{r old corona tsibble TSLM best fit, eval = FALSE}

# model ~ 0 + => w/o intercept
fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)))
# tidy(fit_best)

# provide tibble with Country fatality_rate lag_n
fit_best_coefs <- tidy(fit_best) %>% 
  pivot_wider(id_cols = c(Country), 
              names_from = term, 
              values_from = estimate) %>% 
    rename(fatality_rate = `lag(Confirmed, lag_days)`) %>% 
  mutate(lag_n = lag_days)

fit_best  %>%  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ ACF Correlogram and Histogram"),
       subtitle = paste("Model:", coef(fit_best)$.model, "lag_days:", lag_days))

## provide tibble with Country Date Confirmed Deaths Deaths_calc
# calculate beta_0 * confirmed (note: still to be lagged!)

#  provide tsibble with same tsibble structure and lag_days * new rows w7 NA NA
#   and filling the key-index pair (new next dates, w/ new_data())
corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  new_data(lag_days, keep_all = TRUE) 
corona_deaths_of_confirmed_tbl <- bind_rows(as_tibble(corona_tsbl_lag_range_wide), 
          as_tibble(corona_deaths_of_confirmed)) %>%  
  filter(Country == country) %>% 
  mutate(Deaths_calc = fit_best_coefs$fatality_rate * lag(Confirmed, lag_days))

## plot Daily Deaths plus FC of model(TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_best %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  filter(Country == country)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Daily Deaths based on Confirmed Cases", 
          subtitle = 
            paste(filter(fit_best_coefs, Country == country)$Country, 
                  "- Confirmed Cases lagged by", 
                  filter(fit_best_coefs, Country == country)$lag_n, 
                  "days, ", 
                  "Fatality Rate:",
                  round(filter(fit_best_coefs, Country == country)$fatality_rate, 
                    digits = 3)))
```



```{r old corona tsibble ARIMA lag_range, eval = FALSE}
# model ~ 0 + => w/o intercept
fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(ARIMA(Deaths ~ 0 + pdq(p = 0, d = 0) + 
                          lag(Confirmed, lag_days - 2) + 
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)))
# tidy(fit_best)
# coef(fit_best)

# provide tibble with Country fatality_rate lag_n
fit_best_coefs <- tidy(fit_best) %>% 
  pivot_wider(id_cols = c(Country), 
              names_from = term, 
              values_from = estimate) %>% 
    rename(fatality_rate = `lag(Confirmed, lag_days)`) %>% 
  mutate(lag_n = lag_days)

fit_best  %>%  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ ACF Correlogram and Histogram"),
       subtitle = paste("Model:", coef(fit_best)$.model, "lag_days:", lag_days))

## provide tibble with Country Date Confirmed Deaths Deaths_calc
# calculate beta_0 * confirmed (note: still to be lagged!)

#  provide tsibble with same tsibble structure and lag_days * new rows w7 NA NA
#   and filling the key-index pair (new next dates, w/ new_data())
corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  new_data(lag_days, keep_all = TRUE) 
corona_deaths_of_confirmed_tbl <- bind_rows(as_tibble(corona_tsbl_lag_range_wide), 
          as_tibble(corona_deaths_of_confirmed)) %>%  
  filter(Country == country) %>% 
  mutate(Deaths_calc = fit_best_coefs$fatality_rate * lag(Confirmed, lag_days))

## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_best %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  filter(Country == country)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Daily Deaths based on Confirmed Cases", 
          subtitle = 
            paste(country, "- Confirmed Cases lagged by", 
                  lag_days, "days, ", "Fatality Rate:",
                  round(sum(coef(fit_best)$estimate), 
                    digits = 3)))


```



References
=====================================

***
***
  
### Data Source

**Data Source**

Data files are provided by **Johns Hopkins University** on GitHub  
<https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series>

* Data files:  
    + *time_series_covid19_confirmed_global.csv* 
    + *time_series_covid19_deaths_global*
    + *time_series_covid19_recovered_global.csv*

The data are visualized on their excellent Dashboard  
**Johns Hopkins University Dashboard**  
<https://coronavirus.jhu.edu/map.html>


### Links


[see @CIA2020], [see @CIA2020a]

[@CMMID2020]

[@JHU2020] or [@JHU2020a]

otherwise [@RKI2020] or [@RKI2020a] or [@RKI2020b]

[@WHO2020]

[@Wikipedia2020] or [@Wikipedia2020a] or [@Wikipedia2020b]

**Further links**

**WHO Dashboard**  
<https://experience.arcgis.com/experience/685d0ace521648f8a5beeeee1b9125cd>

**Robert Koch Institut, Germany**  
<https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Fallzahlen.html?nn=13490888>

[RKI Modelling Paper]: https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Modellierung_Deutschland.pdf?__blob=publicationFile) "nachfolgener Text" **RKI Modelling Paper 2020**

**Wikipedia - Exponential Growth**  
<https://en.wikipedia.org/wiki/Exponential_growth>

**World Population - CIA The World Factbook**
<https://www.cia.gov/library/publications/resources/the-world-factbook/fields/335rank.html>
<https://www.cia.gov/library/publications/resources/the-world-factbook/fields/rawdata_335.txt>

**Centre for the Mathematical Modelling of Infectious Diseases (CMMID) at the London School of Hygiene & Tropical Medicine (LSHTM)**  
**Temporal variation in transmission during the COVID-19 outbreak**  
<https://cmmid.github.io/topics/covid19/current-patterns-transmission/global-time-varying-transmission>

**Code Source**

Code is based on ideas from 
<https://rpubs.com/TimoBoll/583802>

### Bibliography {#bib}
