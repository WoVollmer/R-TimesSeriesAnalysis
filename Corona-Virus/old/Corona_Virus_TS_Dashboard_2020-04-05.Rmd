---
title: "Coronavirus SARS-CoV-2 / Covid-19"
author: "Wolfgang Vollmer"
date: '`r Sys.Date()`'
output:
   flexdashboard::flex_dashboard:
   vertical_layout: scroll
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, echo = FALSE, warning = FALSE,      
                      message = FALSE, fig.width = 7, fig.asp = 0.618)

library(flexdashboard)

```


```{r initialization, eval = TRUE, include = FALSE}

################################################################################
##                                                                            ##
## Corona Virus -                                                             ##
##       Analyze Time Series of Confirmed, Death and Recovered Cases          ##
##                                                                            ##
##                                              Wolfgang Vollmer, March 2020  ##
##                                                                            ##
################################################################################

######  variables clean up, library() and	source() statements
# setwd("D:/Wolfgang/Programs-R/R-WeatherAnalysis")
setwd("D:/Wolfgang/Programs-R/R-TimeSeriesAnalysis/Corona-Virus")
rm(list=ls()) # deletes all existing objects / variables !!
Prog.Start <- Sys.time()

library(tidyverse)
library(magrittr)
library(lubridate)
library(fpp3)  # tsibble, tsibbledata, fable, and feasts packages & some tidyverse
library(stlplus) # Enhanced Seasonal Decomposition of Time Series by Loess
library(DT)      # R interface to the JavaScript library DataTables
library(rlang)
library(gridExtra)

library(janitor)
library(highcharter)

library(dygraphs)  # R interface to the dygraphs JavaScript charting library

######  Plot and util functions
# source("./../uts_TimeSeries.R")  # utility functions for time series
# source("./../ggts_TimeSeries.R") # ggplot2 functions for time series plots

theme_replace(
  plot.title = element_text(
    hjust = 0.5, face = "bold.italic", color = "darkcyan", size = 12),
  plot.subtitle = element_text(
    hjust = 0.5, face = "italic", color = "darkcyan")
)
x_axis_theme <- element_text(size = 14)
```


```{r settings}

compare_countries <- c("Austria", "France", "Germany", "Italy", "India",
                       "South Korea", "Spain",  "United States of America")
countries <- c("China", compare_countries)
countries_exp_growth <- c("World", "China", "Germany", "Italy", 
                       "South Korea", "Spain",  "United States of America")
sel_country <- "Germany"

reg_range <- 7   # important - no Cases value = 0 are llowed => log(0) = inf !
# changed from 9 -> 7 days, 
# but whole week is necessary to get rid of weekly fluctuations
forcast_range <- 14  # 14days forecast => unclass(last_date + 1 + forcast_range -1)

```


```{r read data bind rows and chanfge to long format}

# source data file: covid_19_data.csv from
# <https://www.kaggle.com/sudalairajkumar/novel-corona-virus-2019-dataset/>


corona_confirmed <- read_csv(
  "./csse_covid_19_time_series/time_series_covid19_confirmed_global.csv") %>%
  mutate(Case_Type = "Confirmed")
corona_deaths <- read_csv(
  "./csse_covid_19_time_series/time_series_covid19_deaths_global.csv") %>%
  mutate(Case_Type = "Deaths")
corona_recovered <- read_csv(
  "./csse_covid_19_time_series/time_series_covid19_recovered_global.csv")  %>%
  mutate(Case_Type = "Recovered")


corona_wide <- bind_rows(corona_confirmed, corona_deaths, corona_recovered)

corona <- corona_wide  %>%
    pivot_longer(cols = c(-`Province/State`, -`Country/Region`, -Case_Type, 
                          -Lat,  -Long ), 
                 names_to = c("Date"),
                 values_to = "Cases")

corona %<>% mutate(Date = as.Date(Date, format = "%m/%d/%y")) %>% 
  rename(Country = `Country/Region`) 

# without Case_Type "Recovered"  - no real value add, no consistent data
corona %<>% filter(Case_Type != "Recovered")

```


```{r data clean-up}

# clean-up column names
# corona %>% janitor::clean_names()



# United Republic of Tanzania
# Myanmar
# 
# 

# clean-up content of column Country
corona %<>% mutate(
  Country = case_when(
  Country == "Burma" ~ "Myanmar",
  Country == "Mainland China" ~ "China",
  Country == "Hong Kong SAR" ~ "Hong Kong",
  Country == "Holy See" ~ "Holy See (Vatican City)",
  Country == "Iran (Islamic Republic of)" ~ "Iran",
  Country == "Macao SAR" ~ "Macao",
  Country == "occupied Palestinian territory" ~ "Palestine",
  Country == "Republic of Korea" ~ "South Korea",
  Country == "Congo (Brazzaville)" ~ "Republic of the Congo",
  Country == "Congo (Kinshasa)" ~ "Democratic Republic of the Congo",
  Country == "Korea, South" ~ "South Korea",
  Country == "Taiwan*" ~ "Taiwan",
  Country == "Tanzania" ~ "United Republic of Tanzania",
  Country == "US" ~ "United States of America",
  Country == "Viet Nam" ~ "Vietnam",
  TRUE ~ as.character(Country)))

# clean-up content of column `Province/State`
# replace NAs by Country
# replace "Bavaria"  by  Country since `Province/State` exists only until 
# end of January, as begin of February inluded in "Germany" data
# `Province/State` == "Bavaria" ~ Country, not needed in time series format,
#  needed for data file: covid_19_data.csv
corona %<>% mutate(    
  `Province/State` = case_when(
    is.na(`Province/State`) ~ Country,
    TRUE ~ `Province/State`)) %>% 
  arrange(Country, `Province/State`) %>% 
  group_by(Case_Type, Country, `Province/State`)

```


```{r provinces to country data}
# add all data from provinces to country data 
corona_country <- corona %>% 
  group_by(Country, Date, Case_Type) %>% 
  summarise(Cases = sum(Cases, na.rm = TRUE))
corona_country %<>% 
  group_by(Country, Case_Type) %>% 
  mutate(Daily_Cases = c(NA, diff(Cases)))

first_date <- min(corona_country$Date)
last_date <- max(corona_country$Date)

# for sum( , na.rm = TRUE) removing missing values is important,
# otherwise one region with NA (no cases) resulty in NA worldwide
corona_country_last <- corona_country %>% 
  filter(Date == last_date)

### provide sum of all countries as country "World" data

corona_world <- corona_country %>% 
  group_by(Date, Case_Type) %>% 
  summarise(Cases = sum(Cases, na.rm = TRUE))
corona_world %<>% 
  group_by(Case_Type) %>% 
  mutate(Daily_Cases = c(NA, diff(Cases)),
         Country = "World")

corona_world_last <- corona_world %>%
  filter(Date == last_date)

corona_country <- bind_rows(corona_country, corona_world)
corona_country_world_last <- corona_country %>% 
  filter(Date == last_date)

# corona_country %>% filter(Date == last_date)
# corona_world %>% filter(Date == last_date)



```

```{r test slice views, eval = FALSE}

sel_country <- "World"
n_days <- 9
last_n_days <- last_date - n_days + 1  

View(corona %>% 
       filter(Country == sel_country & Date >= last_n_days) %>% 
       arrange(Case_Type)
       )
selection <- corona %>% filter(Country == sel_country & Date >= last_n_days)
(slice(selection, n() -4:0))

View(corona_country %>% 
       filter(Country == sel_country & Date >= last_n_days) %>% 
       arrange(Case_Type)
       )
selection <- corona_country %>% filter(Country == sel_country & Date >= last_n_days)
(slice(selection, n() -4:0))

```


```{r plot functions}
ggts_cases_facet <- function(data, x = Date, y = Cases, col = Case_Type) {
  col_scheme <- "Set1" # "RdYlGn" #"YlOrRd" #"Oranges" # "YlGnBu" # 
  ggplot(data, aes_(substitute(x), substitute(y), col = substitute(Case_Type))) +
    facet_wrap(vars(Case_Type), ncol = 1, scales = "free_y",
               strip.position = "left") +
    geom_point(size = 1.5, na.rm = TRUE) +
    geom_line(size = 1, na.rm = TRUE) +  
    theme(legend.position = "none")  +
    labs(y = "") + 
    scale_x_date(date_labels = "%b %d", date_breaks = "14 days") +
    # scale_colour_distiller(palette = col_scheme, direction = 1) +
    scale_colour_brewer(palette = col_scheme, direction = 1) +
    # scale_color_discrete(c("blue",  "green", "red")) +
    ggtitle("Confirmed and Death Cases")
}

# function to get grid plot with Cases trend and Daily_Cases 
gg_trend_daily <- function(data, i) {
  plot_cases <- ggts_cases_facet(data, y = Cases) +
    labs(title = paste(i, "- Cumulated Cases")) 
  plot_daily_cases <- ggts_cases_facet(data, y = Daily_Cases) +
    labs(title = paste(i, "- Daily Cases"))
  gridExtra::grid.arrange(plot_cases, plot_daily_cases, ncol = 2)
}

```


```{r eval = FALSE}

# World Map {data-orientation=rows}  {data-navmenu="Menu A"}

Row  {data-height=600}
-----------------------------------------------------------------------
```


World Map
=====================================  

***
***

**World Map with Confirmed and Death Cases**    

### Total Confirmed for each Country

```{r World Map Confirmed}
# https://api.highcharts.com/highcharts/title
# https://rdrr.io/cran/highcharter/man/hc_xAxis.html

world_map_plot <- function(data, i) {
  highchart() %>%
    hc_add_series_map(worldgeojson, 
                      data, 
                      value = 'Cases', 
                      joinBy = c('name', 'Country'))  %>% 
    #hc_colors(c("darkorange", "darkgray")) %>% 
    hc_colorAxis(stops = color_stops()) %>% 
    hc_title(text = "Spread of Coronavirus SARS-CoV-2") %>% 
    hc_subtitle(text = paste(i, "- Cumulated Cases / Country - Actual Figures"))
}

# plot total confirmed in world
i <- "Confirmed"
world_map_plot(filter(corona_country_last, Case_Type == i), i)

```


### Total Deaths for each Country

```{r World Map Deaths}

# plot total deaths in world
i <- "Deaths"
world_map_plot(filter(corona_country_last, Case_Type == i), i)

```



Bar Chart {data-orientation=rows, data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Row {data-height=500}
-------------------------------------

### Bar Chart Confirmed

```{r Top Ten Bar Chart Confirmed}
# Visualization with top 10 country bar chart

bar_chart_countries <- function(data, i) {
  data %>%
    arrange(desc(Cases)) %>% 
    head(10) %>%
    hchart("bar",hcaes(x = Country,  y = Cases)) %>%
    hc_title(text = paste(i, "- Number of Cumulated Cases (Descending Order)")) %>% 
    hc_add_theme(hc_theme_sandsignika())
}

# plot bar chart deaths / country
i <- "Confirmed"
bar_chart_countries(filter(corona_country_last, Case_Type == i), i)

```

### Bar Chart Table Deaths

```{r Top Ten Bar Chart Deaths}

# plot bar chart deaths / country
i <- "Deaths"

bar_chart_countries(filter(corona_country_last, Case_Type == i), i)

```


Row {data-height=400}
-------------------------------------

### Data Table of Confirmed and Deaths - Cumulated and Daily Cases


```{r}
# DT::datatable(corona_country_last %>% filter(Case_Type == "Confirmed"),
#               # options=list(bPaginate = FALSE), 
#               options=list(pageLength=25), 
#               width = 400, height = 400)

DT::datatable(corona_country_last %>% filter(Case_Type != "Recovered"),
              options=list(pageLength=25))
```


Bar Chart / Inhabitants {data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Column
-------------------------------------
### Bar Chart Confirmed per 100,000 Inhabitants

```{r Top Ten Bar Chart Population Confirmed}
# Visualization with top 10 country/100k bar chart
# https://rdrr.io/cran/highcharter/man/hc_xAxis.html

bar_chart_countries_pop <- function(data, i) {
  data %>%
    arrange(desc(Cases_100k)) %>% 
    head(20) %>%
    hchart("bar",hcaes(x = Country,  y = Cases_100k)) %>%
    hc_title(text = paste(i, "- Number of Cases per 100k Inhabitants (Descending Order)")) %>% 
    hc_yAxis(title = list(text = ("Cases per 100k Inhabitants"))) %>% 
    hc_add_theme(hc_theme_sandsignika())
}


population_countries <- readRDS("./World_Population/world_population.RDS")
population_total <- sum(population_countries$Population, na.rm = TRUE)
population_world <- tibble(Country = "World", Population = population_total)
population_countries <- bind_rows(population_countries, population_world)
          
# corona_popoluation <- full_join(corona_country_last, population_countries)
corona_popoluation <- full_join(corona_country_world_last, population_countries)

corona_popoluation %<>% 
  mutate(Cases_100k = round(Cases/(Population/100000)), digits = 1)

# plot bar chart deaths / 100k for countries and + world
i <- "Confirmed"
data <- bind_rows(corona_popoluation %>% 
  filter(Case_Type == i, Country != "World") %>% 
  arrange(desc(Cases_100k)) %>% head(19), corona_popoluation %>% 
  filter(Case_Type == i, Country == "World"))


bar_chart_countries_pop(filter(data, Case_Type == i), i)

```

Column
-------------------------------------

### Bar Chart Deaths per 100,000 Inhabitants

```{r Top Ten Bar Chart Population Deaths}

# plot bar chart deaths / country
i <- "Deaths"

data <- bind_rows(corona_popoluation %>% 
  filter(Case_Type == i, Country != "World") %>% 
  arrange(desc(Cases_100k)) %>% head(19), corona_popoluation %>% 
  filter(Case_Type == i, Country == "World"))


bar_chart_countries_pop(filter(data, Case_Type == i), i)

```


```{r}
country <- "World"
```


Cumulated and Daily Trend {data-orientation=rows}
=====================================

***
***

**Cumulated and Daily Cases over Time**  

Row {data-height=400}
------------------------------------

### `r country`

**`r country`**

```{r  Time Series Diagram Worldwide}

gg_trend_daily(corona_country %>% filter(Country == country), country)

```

```{r}

i <- 1

```


Row {.tabset .tabset-fade}
------------------------------------

**Selected Countries**

### `r countries[i]` 

```{r  Time Series Diagram countries 1}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`

```{r  Time Series Diagram countries 2}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`


```{r  Time Series Diagram countries 3}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`


```{r  Time Series Diagram countries 4}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```


### `r countries[i]`


```{r  Time Series Diagram countries 5}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`

```{r  Time Series Diagram countries 6}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`

```{r  Time Series Diagram countries 7}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`

```{r}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```

### `r countries[i]`

```{r}
country <- countries[i]
gg_trend_daily(corona_country %>% filter(Country == country), country)

i <- i + 1
```



```{r  Time Series Confirme dygraph_plot, eval = FALSE}
### Germany - Confirmed

# https://rstudio.github.io/dygraphs/gallery-series-highlighting.html
# dygraph interactive plot for time series data:
# input must be a named list or data frame, where the first element/column
# provides x-axis values and all subsequent elements/columns provide one or more
# series of y-values.

dygraph_plot <- function(data, country, case_type, last_date) {
  data <- data %>% 
    ungroup() %>% 
    filter(Country == country &
             Case_Type == case_type)
  
  index <- data$Date
  data %<>% select(Cases, Daily_Cases)
  
  data_xts <- xts::xts(data, order.by = index)
  
  dygraph(data_xts, 
          main = paste(country, "-", case_type, "- Cumulated and Daily Cases")) %>% 
    dySeries("Cases", drawPoints = TRUE, pointShape = "square") %>% 
    dySeries("Daily_Cases", drawPoints = TRUE, pointShape = "square") %>% 
    dyRangeSelector(dateWindow = 
                      c(as.character(last_date - 28), as.character(last_date)))
}


case_type <- "Confirmed"

dygraph_plot(corona_country, sel_country, case_type, last_date) 
```


### Germany - Confirmed and Deaths

```{r  dygraph_plot all, eval = TRUE}

# https://rstudio.github.io/dygraphs/gallery-series-highlighting.html
# dygraph interactive plot for time series data:
# input must be a named list or data frame, where the first element/column
# provides x-axis values and all subsequent elements/columns provide one or more
# series of y-values.


data <- corona_country %>% 
  ungroup() %>% 
  filter(Country == sel_country) %>% 
  pivot_wider(names_from = Case_Type, 
              values_from = c(Cases, Daily_Cases))

# change tibble in xts object
index <- data$Date
data %<>% select(Cases_Confirmed, Cases_Deaths, 
                 Daily_Cases_Confirmed, Daily_Cases_Deaths)
data_xts <- xts::xts(data, order.by = index)


dygraph(data_xts, 
        main = paste(sel_country, "- Cumulated and Daily Cases")) %>% 
  dyAxis("y", label = "Confirmed Cases") %>%
  dyAxis("y2", label = "Death Cases", independentTicks = TRUE) %>%
  dySeries("Cases_Confirmed", drawPoints = TRUE, pointShape = "square") %>% 
  dySeries("Cases_Deaths", drawPoints = TRUE, pointShape = "square", 
           axis = "y2") %>% 
  dySeries("Daily_Cases_Confirmed", drawPoints = TRUE, pointShape = "square") %>% 
  dySeries("Daily_Cases_Deaths", drawPoints = TRUE, pointShape = "square", 
           axis = "y2") %>% 
  dyRangeSelector(dateWindow = 
                    c(as.character(last_date - 28), as.character(last_date)))


```


```{r  Time Series Deaths dygraph_plot, eval = FALSE}
### Germany - Deaths
case_type <- "Deaths"

dygraph_plot(corona_country, sel_country, case_type, last_date) 
```


Exponential Growth {data-navmenu="Exponential Growth"}
=====================================

***
***

Column {data-width=400}
------------------------------------  

### Estimation speed of spread of the Coronavirus with Linear Regression

**Exponential Growth and Doubling Time $T$**

Exponential growth over time can be fitted by linear regression if the logarithms
of the case numbers is taken. Generally, exponential growth corresponds to
linearly growth over time for the log (to any base) data. 

The semi-logorithmic plot with base-10 log scale for the Y axis shows 
functions following an exponential law $y(t) = y_0 * a^{t/\tau}$
as straight lines. The time constant $\tau$ describes the time required for y to increase by one factor of $a$. 

If e.g. the confirmed or death cases are growing in $t-days$ by a factor of $10$
the doubling time $T \widehat{=} \tau$ can be calculated with $a \widehat{=} 2$ by

<p style="text-align: center;">
$T[days] = \frac {t[days] * log_{10}(2)} {log_{10}(y(t))-log_{10}(y_0)}$
</p>

with    
<p style="text-align: center;">
$log_{10}(y(t))-log_{10}(y_0) = = log_{10}(y(t))/y_0) = log_{10}(10*y_0/y_0) = 1$  
</p>

and doubling time   
<p style="text-align: center;">
$T[days] = t[days] * log_{10}(2) \approx t[days] * 0.30$.
</p>

For Spain, Italy, Germany we have had a doubling time up to $T \approx 9-12 days * 0.3 \approx 2.7 - 4 days !!$. 

The *doubling time $T$* and the *Forecast* is calculated for following
selected countries: **`r compare_countries`**


### `r sel_country` - Trend with Forecast on a linear scale

```{r plot function forecast based on linear regression}

# plot function - forecast based on linear regression on linear scale

ggts_cases_lm <- function(data, x = Date, y = Cases, col = Case_Type) {
  col_scheme <- "Set1" # "RdYlGn" #"YlOrRd" #"Oranges" # "YlGnBu" # 
  ggplot(data, aes_(substitute(x), substitute(y), col = substitute(Case_Type))) +
    facet_wrap(vars(Case_Type), ncol = 1, scales = "free_y",
               strip.position = "left") +
    geom_line(size = 1, na.rm = TRUE) +  
    geom_smooth(data = data %>% filter(Date >= last_date + 1 - reg_range), 
                method="lm", 
                col = "black", size = 1, se=FALSE) +
    geom_point(size = 1.5, na.rm = TRUE) +
    theme(legend.position = "none")  +
    labs(y = "") + 
    scale_x_date(date_labels = "%b %d", date_breaks = "14 days") +
    # scale_colour_distiller(palette = col_scheme, direction = 1) +
    scale_colour_brewer(palette = col_scheme, direction = 1) +
    # scale_color_discrete(c("blue",  "green", "red")) +
    ggtitle("Confirmed and Death Cases")
}

```


```{r corona tsibble reg_range}
corona_tsbl <- corona_country  %>% 
  as_tsibble(index = Date, key = c(Country, Case_Type))

corona_tsbl_reg_range <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% c("World", compare_countries) & 
           Date >= last_date + 1 - reg_range &
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

# linear regression of log data

```


```{r example, fig.width = 10, fig.height = 5}

fit_corona <- corona_tsbl_reg_range %>% ungroup() %>% 
  group_by(Case_Type) %>% 
  model(TSLM(log(Cases) ~ Date)) 
fc_corona <- fit_corona %>% fabletools::forecast(h = "14 days") 

fc_corona %>%  
  filter(Country == sel_country) %>% 
  autoplot(corona_tsbl_reg_range) +
  ggtitle(paste(sel_country, "- Cases and 14-days Forecast on linear y-scale"),
            subtitle = "Example shows the extreme fast increase on linear scale") +
  labs(x = "Days") +
  # scale_y_log10() +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```


### Forecast Plot - next `r forcast_range` days {data-height=150}

The plot shows the extreme forecast increase in case of unchecked exponentiell 
growth. The dark shaded regions show 80% rsp. 95% prediction intervals. These prediction intervals are displaying the uncertainty in forecasts based on the 
linear regression over the past `r reg_range` days.

Column {data-width=600}
------------------------------------ 

### Comparison Exponential Growth 


```{r plot countries on log10scale}
  
gg_logscale <- function(data) {
  gg_plot <-  
    ggplot(data, aes(x=Date, y=log10(Cases))) +
    labs(x = "Date", y = "Cumulated Cases",
         title = 
           "Virus Spread (with log10 scale) - World and selected Countries") + 
    geom_point(aes(col = Country)) +
    # geom_line(aes(col = Country), size = 1) +
    # geom_smooth(method="lm", aes(col = Country), lty = "dashed", se=FALSE) +
    theme(legend.position = "bottom") +
    facet_wrap(vars(Case_Type), ncol = 2, scales = "free_y",
               strip.position = "left") 
}

```


```{r plot log10scale selected Country}

labels_scale <- c(10, 100, 1000, 5000, 10000, 50000, 100000, 500000)

gg_plot <- gg_logscale(corona_tsbl_reg_range)  +
  geom_smooth(method="lm", aes(col = Country), lty = "dashed", se=FALSE)
  
gg_plot +
  scale_y_continuous(breaks = log10(labels_scale), label = labels_scale) +
  labs(subtitle = paste("Past", reg_range, "days with Linear Regression"))

```



### Germany - Example plot with ~linear slope on a log10 scale {data-height=400}

```{r  Plot with Linear Regression}

for (i in sel_country) { 
  plot_cases <- 
    ggts_cases_facet(corona_country %>% 
                        filter(Country == i & Case_Type != "Recovered")) +
      labs(title = paste(i, "- Cumulated Cases")) +
    scale_y_log10()
  plot_daily_cases <- ggts_cases_lm(
    corona_country %>% 
      filter(Country == i & Case_Type != "Recovered" & Date >= last_date + 1 - 28)) +
            labs(title = paste("w/ linear regression of past", reg_range, "days"))  +
    scale_y_log10() +
    scale_x_date(date_labels = "%b %d", date_breaks = "7 days")
gridExtra::grid.arrange(plot_cases, plot_daily_cases, ncol = 2)
}

```

Exponential Growth since Jan {data-navmenu="Exponential Growth"}
=====================================

***
***


Column {data-width=200}
-------------------------------------

### Exponential Growth Evaluation

China and South Korea have slowed down significantly the exponential growth.
Therefore, their lines in the chart with the log10 scale no longer have a 
significant.
 
Most other countries are still in a phase of more or less unchecked exponentiell
growth. For Italy, the reduced exponential growth is reflected in a reduced slope
of the cumulated cases. 

Column
-------------------------------------

### Virus Spread since mid of January 


```{r plot log10scale w/o date filter, fig.width = 7, fig.asp = 1.5}

# logscale plot w/o date filter
data <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% countries_exp_growth & 
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

gg_plot <- gg_logscale(data)
  
gg_plot + 
  scale_y_continuous(breaks = log10(labels_scale), label = labels_scale) +
  geom_line(aes(col = Country), size = 0.5) +
  labs(subtitle = paste("Since", first_date)) +
  facet_wrap(vars(Case_Type), ncol = 1, scales = "free_y",
             strip.position = "left") 

```

Doubling Time / Forecast {data-navmenu="Forecast"}
=====================================

***
***

Column {data-width=500}
-------------------------------------

**Doubling Time and Forecast**

The forecasted cases for the next 14 days are calculated 'only' from the
linear regression of the logarithmic data and are not considering any effects of 
measures in place. In addition data inaccuracies are not taken into account, 
especially relevant for the confirmed cases. 

Therefore the 14 days forecast is only an indication for the direction of an 
unchecked exponentiell growth.

```{r calculate forecast with beta_0 and beta_1, eval = TRUE}

coefs <- tidy(fit_corona) %>% 
  group_by(Country, Case_Type) %>% 
  mutate(T_doubling = (log(2) /estimate))

forecast_country <- coefs %>% 
  pivot_wider(id_cols = c(Country, Case_Type), 
              names_from = term, 
              values_from = estimate) %>% 
  rename(beta_0 = `(Intercept)`,
         beta_1 = Date) %>% 
  mutate(T_doubling = (log(2) / beta_1),
         FC_next_day = exp(beta_0 + unclass(last_date + 1) * beta_1),
         FC_14days = exp(beta_0 + unclass(last_date + 1 + forcast_range-1) 
                              * beta_1)) 

forecast_table <- forecast_country %>%
  filter(Case_Type != "Recovered") %>% 
  group_by(Country, Case_Type) %>%
  summarise(T_doubling = sum(T_doubling, na.rm = TRUE),
            FC_next_day = sum(FC_next_day, na.rm = TRUE),
            FC_14days = sum(FC_14days, na.rm = TRUE)) %>% 
  arrange(Case_Type)

countries_last_day <- corona_country %>% 
  filter(Country %in% c(compare_countries, "World") & 
           Date == last_date &
           Case_Type != "Recovered") %>%
  rename(last_day = Cases) %>% 
  arrange(Case_Type) %>% 
  select(Country, Case_Type, last_day)

forecast_table <- left_join(forecast_table, countries_last_day) %>% 
  select(Country, Case_Type, T_doubling, last_day, 
         FC_next_day, FC_14days)

knitr::kable(forecast_table,  digits = c(0, 0, 1, 0, 0),
             format.args = list(big.mark = "'"),
             caption = 
             "Forecast (FC) with linear regression: Doubling Time (days), 
             Forecasted cases tomorrow and  Forecasted cases in 14 days")

# check
# corona %>%  filter(Country %in% compare_countries, Date >= last_date + 1 - 1) 

```

Column
-----------------------------------------------------------------------  

### Check of Forecast Accuracy {data-height=200}

The forecast accuracy is checked by using the forecast method for the nine days
before the past three days (*training data*). Subsequent forecasting of the 
past three days enables comparison with the real data of these days (*test data*).

The comparison is also an early indicator if the *exponential growth* is declining. However, possible changes in underreporting
(in particular the proportion confirmed / actually infected) requires careful interpretation.


### Germany - Forecast Accuracy for past three days
```{r forecasts accuracy, fig.width = 10, fig.height = 5}
# Note: as long as zero deaths are in this time range log(0) will go to infinity,
# therefore still no linear regression possible.

training_data_start <- 12 #reg_range + 3  # minus 12 days
training_data_end   <- 3  #reg_range - 6  # minus  3 days
# total = training + test_data => 
#    Date >= last_date + 1 - training_data_start = last 3 days

corona_tsbl_train <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% sel_country & 
           Date >= last_date + 1 - training_data_start &
           Date < last_date + 1 - training_data_end &
           Case_Type != "Recovered") %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

corona_tsbl_total <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% sel_country  & 
           Date >= last_date + 1 -  training_data_start &
           Case_Type != "Recovered") %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

fit_corona_train <- corona_tsbl_train %>% ungroup() %>% 
  group_by(Case_Type) %>% 
  model(TSLM(log(Cases) ~ Date)) 
fc_corona_train <- fit_corona_train %>% 
  fabletools::forecast(h = "3 days") 

# forecasts accuracy
# for evaluating accuracy on forecasts to be provided:
# - a complete dataset that includes the future data and 
# - data used to train the model.

# level = prediction interval in % or NULL
fc_corona_train %>%
  filter(Country == sel_country) %>% 
  autoplot(corona_tsbl_total) +
  labs(x = "Year",
       title = paste(sel_country, "Forecast Accuracy"),
       subtitle = "Forecast (blue line) vs. Data (black line)") +
    facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left") +
  scale_x_date(date_labels = "%b %d", date_breaks = "2 days") +
  ggtitle("Forecast Accuracy")

```

Forecast {data-navmenu="Forecast"}
=====================================

***
***

Column {data-width=400}
-------------------------------------

### Forecasting with lagged Predictors


The number of confirmed cases can be used as a time delayed predictor of the 
number of deaths. This will allow comclusions on the time period confirmed to 
death. More inportant the country specific case fatality rate (CFR, proportion 
of deaths from confirmed cases) indicates the country specific testing. 

Overall a rough conclusion on the country specific proportion of infected to 
confirmed cases is feasible if the infection fatality rate (IFR, 
confiremd cases plus all asymptomatic and undiagnosed infections) is assumed to 
be country independent and the IFR is known (bottom of existing estimates ~ 0.56%,
assumption by RKI see 
https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Modellierung_Deutschland.pdf?__blob=publicationFile ).

Therefore an estimation of the CFR of $0.06$ $(6\%)$ indicates an
underreporting or lack of diagnostic confirmation by a by a factor of ~$10$. 
A CFR of $0.20$ $(20\%)$ indicates an underreporting by a by a factor of ~$30$.
This corresponds to RKI assumption of a underreporting by a factor of $11-20$ (https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Steckbrief.html).


In the model paper RKI assumes for the

* Incubation period ~ 5-6 days - Day of infection day until symptoms are upcoming)
* Hospitalisation +4 days  - Admission to the hospital (if needed) after Incubation Period)
* Average period to death + 11 - if the patient dies, it takes an average of 
11 days after admission to the hospital

Depending on the country-specific test frequency (late or early tests), 
the 

*lag_days - time from receipt of the confirmed test result to death, Confirmed to Death, 
is about 11-13 days.


Note: these methods are also used for example for advertising campaigns. The
campaign impact on sales will be some time beyond the end of the campaign, and 
sales in one month will depend on the advertising expenditure in each of the 
past few months (see https://otexts.com/fpp3/lagged-predictors.html).


Column {data-width=600}
-------------------------------------

### Daily Confirmed and Death Cases

```{r eval = TRUE}

# avg_days_to_confirmed  # Incubation period ~ 5-6 days; Hospitalisation + 4 days
# avg_days_to_death      # death     ~ after 21 days
# lag_n                  # avg_days_to_death - (period infected to confirmed)
# case_fatality_rate     # proportion of deaths / number of people diagnosed
#                                                                   (Confirmed)

lag_germany <- 13
lag_italy <- 10
lag_spain <- 11

countries_to_forecast <- c("Germany", "Italy", "Spain")

countries_fc_param <-
  tibble(Country = countries_to_forecast,
       confirmed_to_death = c(lag_germany, lag_italy , lag_spain),
       infected_to_death     = 21,
       case_fatality_rate = c(0.06, 0.25, 0.3)) %>% 
  mutate(infected_to_confirmed = infected_to_death  - confirmed_to_death)

# countries_fc_param <-
#   tibble(Country = countries_to_forecast,
#        avg_days_to_confirmed = c(8, 9, 10),
#        avg_days_to_death     = 21,
#        case_fatality_rate = c(0.1, 0.5, 0.5)) %>% 
#   mutate(lag_n = avg_days_to_death  - avg_days_to_confirmed )
#        
```


```{r eval = TRUE}

corona_country_sel <- corona_country %>% 
  filter(Country %in% countries_to_forecast & 
           Case_Type != "Recovered" &
           Date >= last_date - 28) %>%
  ungroup() %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

fc_corona_sel <- fc_corona %>% 
  filter(Country %in% countries_to_forecast &
           Date <= last_date + 8) %>% 
  mutate(Case_Type = case_when(
    Case_Type == "Confirmed" ~ "FC_Confirmed",
    Case_Type == "Deaths" ~ "Exp_growth"))
fc_corona_sel %<>% as_tibble(fc_corona_sel) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

corona_country_sel <- bind_rows(corona_country_sel, fc_corona_sel)
```

```{r Daily Confirmed lagged, eval = TRUE, fig.width = 6, fig.asp = 1.2}

# strip.position = "left"

ggts_conf_deaths_facet <- function(data, x = Date, y = Cases, col = Case_Type) {
  col_scheme <- "Set1" # "RdYlGn" #"YlOrRd" #"Oranges" # "YlGnBu" # 
  ggplot(data, aes_(substitute(x), substitute(y), col = substitute(Case_Type))) +
    facet_grid(vars(Country, Case_Type), scales = "free_y") +
    geom_point(size = 1.5, na.rm = TRUE) +
    geom_line(size = 1, na.rm = TRUE) +  
    theme(legend.position = "none")  +
    labs(y = "") + 
    scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
    # scale_colour_distiller(palette = col_scheme, direction = 1) +
    scale_colour_brewer(palette = col_scheme, direction = 1) +
    # scale_color_discrete(c("blue",  "green", "red")) +
    ggtitle("Confirmed and Death - Daily Cases")
}



data <- corona_country %>%  filter(Country %in% countries_to_forecast &
           Date >= last_date - 21)

ggts_conf_deaths_facet(data, y = Daily_Cases, col = Country) # +
    # labs(title = paste(i, "- Daily Cases"))
```


```{r Deaths compared lagged, eval = FALSE, fig.width = 6, fig.asp = 0.618}

ggts_conf_death <- function(data, x = Date, y = Cases, col = Case_Type) {
  col_scheme <- "Set1" # "RdYlGn" #"YlOrRd" #"Oranges" # "YlGnBu" # 
  ggplot(data, aes_(substitute(x), substitute(y), col = substitute(Case_Type))) +
    geom_point(size = 1.5, na.rm = TRUE) +
    geom_line(size = 1, na.rm = TRUE) +  
    labs(y = "") + 
    scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
    # scale_colour_distiller(palette = col_scheme, direction = 1) +
    scale_colour_brewer(palette = col_scheme, direction = 1) 
  # scale_color_discrete(c("blue",  "green", "red"))
}
   
for (country in countries_fc_param$Country) {
corona_wide <- corona_country_sel %>% 
  filter(Country == country)
lag_n <- filter(countries_fc_param, Country == country)$confirmed_to_death
case_fatality_rate <- 
  filter(countries_fc_param, Country == country)$case_fatality_rate 
corona_wide %<>%   
  pivot_wider(id_cols = c(Country, Date), 
              names_from = Case_Type, 
              values_from = Cases) %>% 
  mutate(Confirmed_lag_n = case_fatality_rate * lag(Confirmed, lag_n))

data <- corona_wide %>% 
      pivot_longer(cols = c(-Country, -Date, -FC_Confirmed), 
                 names_to = "Case_Type",
                 values_to = "Cases")

# print(ggts_cases_facet(data))

plot <- ggts_conf_death(data %>% filter(Case_Type != "Confirmed"),
                y = Cases) +
    labs(title = "Death Cases compared to lagged Confirmed Cases",
         subtitle = paste(country, "- Confirmed Cases lagged by", lag_n, "days, ", 
                          "Fatality Rate:", case_fatality_rate))

print(plot)
}
```




```{r Italy data correction}

### corrrection for Italy on "2020-03-12" required, cases  are 0 => no usefull fit
#  Country Date       Case_Type Cases Daily_Cases
#   <chr>   <date>     <chr>     <dbl>       <dbl>
# 1 Italy   2020-03-12 Confirmed 12462           0
# 2 Italy   2020-03-12 Deaths      827           0
# 3 Italy   2020-03-13 Confirmed 17660        5198
# 4 Italy   2020-03-13 Deaths     1266         439

corona_replace_rows <- corona_country %>%
  filter(Country == "Italy" &
           Date >= date("2020-03-12") &
           Date <= date("2020-03-13")
         ) %>%
  mutate(Daily_Cases = mean(Daily_Cases))

# save_corona_country <- corona_country
# test <- corona_country %>% 
#   filter(Country != "Italy" |
#            (Date != date("2020-03-12") & Date != date("2020-03-13")))
# test %>%
#   filter(Country == "Italy" &
#            Date >= date("2020-03-07") &
#            Date <= date("2020-03-14") )

corona_country <- bind_rows(corona_replace_rows,
          corona_country %>% filter(Country != "Italy" |
                   (Date != date("2020-03-12") & Date != date("2020-03-13")))
          )

corona_tsbl <- corona_country  %>%
  as_tsibble(index = Date, key = c(Country, Case_Type))
#######

```

```{r }

# identify "best" lag_day with lowest AICc 

lag_days <-  max(countries_fc_param$confirmed_to_death)
lag_range <- lag_days + 21
country <- countries_to_forecast[1]


corona_tsbl_lag_range <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% countries_to_forecast &
           Case_Type != "Recovered" &
           Date >= last_date - lag_range) %>% 
  dplyr::select(Date, Country, Case_Type, Daily_Cases) %>% 
  group_by(Country)

```


```{r plot facet daily confirmed and daily deaths, eval = FALSE}

corona_tsbl_lag_range %>% 
  filter(Country == country) %>% 
  ggplot(aes(x = Date, y = Daily_Cases)) +
  geom_line() +
  facet_grid(vars(Case_Type), scales = "free_y") +
  labs(x = "Day", y = NULL,
       title = paste(country, "- Daily Confirmed and Death Cases"),
       subtitle = "w/o lagging and w/o fatality factor")

```

```{r}
## wide format to get Daily Deaths as function of Daily Confirmed Cases
corona_tsbl_lag_range_wide <- corona_tsbl_lag_range %>%   
  pivot_wider(id_cols = c(Country, Date), 
              names_from = Case_Type, 
              values_from = Daily_Cases) %>% 
  as_tsibble(index = Date, key = c(Country))
  
no_values <- nrow(corona_tsbl_lag_range_wide %>% filter(Country == country)) 

```


```{r caluclate lag confirmed country dependent, fig.width = 6, fig.asp = 0.618}

lm_term <- c("lag(Confirmed, lag_days - 2)",
             "lag(Confirmed, lag_days - 1)",
             "lag(Confirmed, lag_days)",
             "lag(Confirmed, lag_days + 1)",
             "lag(Confirmed, lag_days + 2)")

country_table <- tibble()
save_plot_fit <- list()
for (country in countries_to_forecast) {
  lag_days <- (countries_fc_param %>% 
                 filter(Country == country))$confirmed_to_death
  # model ~ 0 + => w/o intercept
  fit_best <- corona_tsbl_lag_range_wide %>% 
    filter(Country == country) %>% 
    model(ARIMA(Deaths ~ 0 + pdq(d = 0) + 
                  lag(Confirmed, lag_days - 2) +
                  lag(Confirmed, lag_days - 1) +
                  lag(Confirmed, lag_days) +
                  lag(Confirmed, lag_days + 1) +
                  lag(Confirmed, lag_days + 2)
    ))
  if (country == "Germany") {
    fit_best_germany <- fit_best
  }

    corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>%
    new_data(lag_days, keep_all = TRUE)
  
  
  ## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
  plot_fit <- fit_best %>%
    forecast(corona_deaths_of_confirmed) %>%
    autoplot(corona_tsbl_lag_range_wide %>%  
               filter(Date >= last_date - 20)) + 
    ylab("Daily Deaths") +
    ggtitle(paste(country, "Forecast Daily Deaths based on Confirmed Cases"), 
            subtitle = paste("ARIMA-Model, lag Confirmed:", lag_days, "days"))
  save_plot_fit[[country]] <- plot_fit
  country_table_new <- c(Country = country, 
                         lag_Confirmed = lag_days, 
                         CFR = as.numeric(
                           round(coef(fit_best) %>%  
                                   filter(term %in% lm_term) %>%
                                   summarise(CFR = sum(estimate)), digits = 2))
  )
  country_table <- bind_rows(country_table, country_table_new)
}



```


### Lag days and Case Fatality Rate (CFR)  {data-height=150}

```{r }

knitr::kable(country_table,
             digits = 2, caption =
               "Lag days and CFR (proportion of deaths from confirmed cases)")


# lm_term <- c("lag(Confirmed, lag_days - 2)",
#              "lag(Confirmed, lag_days - 1)",
#              "lag(Confirmed, lag_days)",
#              "lag(Confirmed, lag_days + 1)",
#              "lag(Confirmed, lag_days + 2)")
# 
# knitr::kable(coef(fit_best) %>% 
#                group_by(Country) %>% filter(term %in% lm_term) %>%  
#                summarise(CFR = sum(estimate) ), 
#              digits = 2, caption = 
#                "Case Fatality Fate (CFR, proportion of deaths from confirmed cases)")
```

Forecast residuals indicate quality of fit with Arima model:

`r coef(fit_best)$.model[1]` .



Column
-------------------------------------

### Daily Deaths depending on lagged Daily Confirmed Cases


```{r plot lag confirmed country dependent, fig.width = 6, fig.asp = 0.618}

save_plot_fit$Germany

save_plot_fit$Italy

save_plot_fit$Spain

```


```{r corona tsibble identify TSLM model, eval = FALSE}

# model ~ 0 + => w/o intercept
fit_tslm_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>% 
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_m3 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 3)),
        lag_m2 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 2)),
        lag_m1 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days - 1)),
        lag_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_1 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 1)),
        lag_2 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 2)),
        lag_3 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days + 3)),

  )
# identify lowest AICc value for best fit
glance(fit_tslm_lag) %>% arrange(AICc)

# Residual accuracy - can be computed directly from models as the 
# one-step-ahead fitted residuals are available  
# identify lowest RMSE, MAE value for best fit
fit_tslm_lag %>% accuracy() %>% arrange(RMSE, MAE) 

cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_tslm_lag) %>%
  features(.resid, ljung_box, lag = 4) %>% arrange(desc(lb_pvalue))

```


```{r corona tsibble TSLM best fit, eval = FALSE, fig.width = 5, fig.asp = 0.618}

# model ~ 0 + => w/o intercept
fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)))
# tidy(fit_best)

# provide tibble with Country fatality_rate lag_n
fit_best_coefs <- tidy(fit_best) %>% 
  pivot_wider(id_cols = c(Country), 
              names_from = term, 
              values_from = estimate) %>% 
    rename(fatality_rate = `lag(Confirmed, lag_days)`) %>% 
  mutate(lag_n = lag_days)

fit_best  %>%  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ ACF Correlogram and Histogram"),
       subtitle = paste("Model:", coef(fit_best)$.model, "lag_days:", lag_days))

## provide tibble with Country Date Confirmed Deaths Deaths_calc
# calculate beta_0 * confirmed (note: still to be lagged!)

#  provide tsibble with same tsibble structure and lag_days * new rows w7 NA NA
#   and filling the key-index pair (new next dates, w/ new_data())
corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  new_data(lag_days, keep_all = TRUE) 
corona_deaths_of_confirmed_tbl <- bind_rows(as_tibble(corona_tsbl_lag_range_wide), 
          as_tibble(corona_deaths_of_confirmed)) %>%  
  filter(Country == country) %>% 
  mutate(Deaths_calc = fit_best_coefs$fatality_rate * lag(Confirmed, lag_days))

## plot Daily Deaths plus FC of model(TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_best %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  filter(Country == country)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Daily Deaths based on Confirmed Cases", 
          subtitle = 
            paste(filter(fit_best_coefs, Country == country)$Country, 
                  "- Confirmed Cases lagged by", 
                  filter(fit_best_coefs, Country == country)$lag_n, 
                  "days, ", 
                  "Fatality Rate:",
                  round(filter(fit_best_coefs, Country == country)$fatality_rate, 
                    digits = 3)))
```

```{r corona tsibble identify ARIMA model, eval = FALSE}

# identify "best" lag_day with lowest AICc 
lag_days_1 <- lag_days + 1
lag_days_2 <- lag_days + 2

# model ~ 0 + => w/o intercept
fit_arima_lag <- corona_tsbl_lag_range_wide %>%
  filter(Country == country) %>%
  # Restrict data so models use same fitting period
  mutate(Deaths = c(rep(NA, 3), Deaths[(4):no_values])) %>%
  # Estimate models
  model(lag_A_0 = ARIMA(Deaths ~ 0 + pdq(d = 0) + lag(Confirmed, lag_days)),
        lag_T_0 = TSLM(Deaths ~ 0 + lag(Confirmed, lag_days)),
        lag_A_1 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1)),
        lag_A_2_0 = ARIMA(Deaths ~ 0 + pdq(p=0, d = 0, q = 0) + 
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +
                          lag(Confirmed, lag_days - 2) +
                          lag(Confirmed, lag_days - 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days + 1) +
                          lag(Confirmed, lag_days + 2)),
        lag_T_2 = TSLM(Deaths ~ 0 +
                         lag(Confirmed, lag_days - 2) +
                         lag(Confirmed, lag_days - 1) +
                         lag(Confirmed, lag_days) +
                         lag(Confirmed, lag_days + 1) +
                         lag(Confirmed, lag_days + 2)),
  )
# identify lowest AICc value for best fit
glance(fit_arima_lag) %>% arrange(AICc)
# tidy(fit_arima_lag)
coef(fit_arima_lag)
# report(fit_arima_lag)

# Residual accuracy - can be computed directly from models as the 
# one-step-ahead fitted residuals are available  
# identify lowest RMSE, MAE value for best fit
fit_arima_lag %>% accuracy() %>% arrange(RMSE, MAE) 

cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_arima_lag) %>%
  features(.resid, ljung_box, lag = 10) %>% arrange(desc(lb_pvalue))


corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>%  
  new_data(lag_days, keep_all = TRUE)

## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_arima_lag %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Accuracy", 
          subtitle = paste("TSLM and ARIMA-Models, lag Confirmed:", lag_days, "days"))

as.character(format(fit_arima_lag$lag_A_0))
as.character(format(fit_arima_lag$lag_A_1))
as.character(format(fit_arima_lag$lag_A_2))
as.character(format(fit_arima_lag$lag_A_2_0))


fit_selected <- fit_arima_lag %>% 
  select(Country, lag_A_0, lag_A_1, lag_A_2, lag_A_2_0)
  # select(Country, lag_A_0, lag_T_0, lag_A_2, lag_T_2)

fit_selected %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Accuracy", 
          subtitle = paste("TSLM and ARIMA-Models, lag Confirmed:", lag_days, "days"))
```

```{r corona tsibble compare TSLM ARIMA model, eval = FALSE}

fit_best <- corona_tsbl_lag_range_wide %>% 
  filter(Country == country) %>% 
  model(lag_A_2 = ARIMA(Deaths ~ 0 + pdq(d = 0) +  # pdq(p = 0, d = 0, q = 0) + 
                          lag(Confirmed, lag_days - 2) + 
                          lag(Confirmed, lag_days- 1) +
                          lag(Confirmed, lag_days) +
                          lag(Confirmed, lag_days+ 1) +
                          lag(Confirmed, lag_days + 2)))
coef(fit_best)
report(fit_best)
fit_best %>% accuracy() %>% arrange(RMSE, MAE) 

# ljung_box Test: dof - Degrees of freedom of the fitted model 
#                           (useful if x is a series of residuals)
cat("Null Hypothesis of independence/white noise for residuals - for p < 0.05: reject H_0\n")
augment(fit_best) %>%
  features(.resid, ljung_box, lag = 10) %>% arrange(desc(lb_pvalue))

filter(residuals(fit_best)) %>%
  ACF(.resid, lag.max = 36) %>% autoplot() +
  labs(title = "ACF - Forecast Residuals", subtitle ="ets")
filter(residuals(fit_best)) %>%
  PACF(.resid, lag.max = 36) %>% autoplot() +
  labs(title = "PACF - Forecast Residuals", subtitle ="ets")

# not working !
# fit_best  %>% 
#   gg_tsresiduals(plot_type = "partial") +
#   labs(title = paste(country, "-  Forecast Residuals w/ Correlogram and PACF"),
#        subtitle = paste("Model: ", coef(fit_best)$.model[1], "lag_days:", lag_days))

fit_best  %>% 
  gg_tsresiduals() +
  labs(title = paste(country, "-  Forecast Residuals w/ Correlogram and Histogram"),
       subtitle = paste("Model: ", coef(fit_best)$.model[1], "lag_days:", lag_days))

```


```{r corona tsibble ARIMA lag_range, fig.width = 5, fig.asp = 1.2, eval = FALSE}


# model ~ 0 + => w/o intercept
# fit_best <- corona_tsbl_lag_range_wide %>%
#   # filter(Country == country) %>%
#   model(ARIMA(Deaths ~ 0 + pdq(d = 0) +
#                           lag(Confirmed, lag_days - 2) +
#                           lag(Confirmed, lag_days - 1) +
#                           lag(Confirmed, lag_days) +
#                           lag(Confirmed, lag_days + 1) +
#                           lag(Confirmed, lag_days + 2)))
# tidy(fit_best)
# coef(fit_best)
# glance(fit_best)
# report(fit_best)

# provide tibble with Country fatality_rate lag_n
# fit_best_coefs <- tidy(fit_best) %>% 
#   pivot_wider(id_cols = c(Country), 
#               names_from = term, 
#               values_from = estimate) %>% 
#     rename(fatality_rate = `lag(Confirmed, lag_days)`) %>% 
#   mutate(lag_n = lag_days)


# provide tsibble with same tsibble structure and lag_days * new rows w/ NA NA
#  and filling the key-index pair (new next dates, w/ new_data())
corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide %>%
  new_data(lag_days, keep_all = TRUE)


## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
fit_best %>%
  forecast(corona_deaths_of_confirmed) %>%
  autoplot(corona_tsbl_lag_range_wide %>%  
             filter(Date >= last_date - 20)) + 
  ylab("Daily Deaths") +
  ggtitle("Forecast Daily Deaths based on Confirmed Cases", 
          subtitle = paste("ARIMA-Model, lag Confirmed:", lag_days, "days"))



             

```

### Exampla Germany - White Noise of Forecast Residuals  {data-height=150}

```{r corona ARIMA tsresiduals, fig.width = 5, fig.asp = 0.618}


fit_best_germany  %>% 
  gg_tsresiduals() +
  labs(title = paste("Germany -  Forecast Residuals w/ Correlogram and Histogram"),
       subtitle = paste("Model: ARIMA w/ lagged predictor; lag_days:", lag_germany))
```

```{r}

```



References
=====================================

***
***
  
### Data Source

**Data Source**

Data files are provided by **Johns Hopkins University** on GitHub  
<https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series>

* Data files:  
*time_series_covid19_confirmed_global.csv*,  
*time_series_covid19_deaths_global*
*time_series_covid19_recovered_global.csv*

Note: as of 2020-03-27 recovered cases are provided again 

The data are visualized on their excellent Dashboard  
**Johns Hopkins University Dashboard**  
<https://coronavirus.jhu.edu/map.html>


### Links

**Further links**

**WHO Dashboard**  
<https://experience.arcgis.com/experience/685d0ace521648f8a5beeeee1b9125cd>

**Robert Koch Institut, Germany**  
<https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Fallzahlen.html?nn=13490888>

**Wikipedia - Exponential Growth**  
<https://en.wikipedia.org/wiki/Exponential_growth>

**World Population - CIA The World Factbook**
<https://www.cia.gov/library/publications/resources/the-world-factbook/fields/335rank.html>
<https://www.cia.gov/library/publications/resources/the-world-factbook/fields/rawdata_335.txt>

**Code Source**

Code is based on ideas from 
<https://rpubs.com/TimoBoll/583802>
