---
title: "Coronavirus SARS-CoV-2 / Covid-19"
author: "Wolfgang Vollmer"
date: '`r Sys.Date()`'
link-citations: yes
cite-color: "green"
bibliography: References_Corona.bib
output:
   flexdashboard::flex_dashboard:
   vertical_layout: scroll
params:
  device: "desktop"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, echo = FALSE, warning = FALSE,      
                      message = FALSE, fig.width = 7, fig.asp = 0.618)

# csl: "./../Bibliography/bluebook-law-review.csl"
# csl: bluebook-law-review.csl
# csl: harvard1.csl
# csl: ieee.csl

################################################################################
##                                                                            ##
## Corona Virus -                                                             ##
##       Analyze Time Series of Confirmed, Death and Recovered Cases          ##
##                                                                            ##
##                                          Wolfgang Vollmer,   July  2, 2020 ##
##                                              First Version: March 12, 2020 ##
##                                                                            ##
## URL:                                                                       ##
## https://github.com/WoVollmer/R-TimesSeriesAnalysis/tree/master/Corona-Virus##  
################################################################################
library(flexdashboard)
library(tidyverse)
library(magrittr)
library(lubridate)
library(slider) # for rolling analysis using window functions
library(fpp3)  # tsibble, tsibbledata, fable, and feasts packages & some tidyverse
library(slider) # sliding window functions - rolling averages, cumulative sums
library(DT)      # R interface to the JavaScript library DataTables
library(patchwork) # package for composing plots
          # https://www.data-imaginist.com/2019/patch-it-up-and-send-it-out/
library(gghighlight) 
# https://cran.r-project.org/web/packages/gghighlight/vignettes/gghighlight.html
# library(gridExtra)
# library(janitor)
library(plotly)
library(highcharter)
library(dygraphs)  # R interface to the dygraphs JavaScript charting library

```

```{r path on desktop vs. notebook, eval = TRUE}
# device <- "desktop" # "notebook"  # to define setwd() and data path
# defined as params  metadata in YAML header
device <- params$device

if (device == "desktop") {
  setwd("D:/Wolfgang/Programs-R/R-TimeSeriesAnalysis/Corona-Virus")
  data_path <- 
    "D:/Wolfgang/WoDocs/GitHub/COVID-19/csse_covid_19_data/csse_covid_19_time_series"
} else if (device == "notebook") {
  # attention: here we have (whyever) TimesS.. (Time + s) instead of TimeS..
  setwd("C:/Wolfgang/Programs-R/R-TimesSeriesAnalysis/Corona-Virus")
  data_path <- 
    "C:/Wolfgang/Programs-R/COVID-19/csse_covid_19_data/csse_covid_19_time_series"
} else if (device == "linux") {
  # attention: here we have (whyever) TimesS.. (Time + s) instead of TimeS..
  setwd("/home/wolfgang-ubuntu/Programs-R/R-TimesSeriesAnalysis/Corona-Virus")
  data_path <- 
    "/home/wolfgang-ubuntu/GitHub/COVID-19/csse_covid_19_data/csse_covid_19_time_series"
} else {
  stop("no valid device outlined")
}

```

```{r source function and population data}

# Plot and util functions - has to come after setwd()  ------------
source("./ggts_corona.R") # ggplot2 functions for time series plots
source("./uts_corona.R")  # utility functions for corona analysis

# read world population for normalization per 100k inhabitants
# population_countries <- readRDS("./world_population.RDS") # data from CIA
population_countries <- readRDS("./world_population_un.RDS") # data from UN

```


```{r initialization, eval = TRUE, include = FALSE}

# variables clean up, library() and	source() statements ----------------------
# deletes params$device => not allowed
# rm(list=ls()) # deletes all existing objects / variables !!

# Prog.Start <- Sys.time()

theme_replace(
  plot.title = element_text(
    hjust = 0.5, face = "bold.italic", color = "darkcyan", size = 12),
  plot.subtitle = element_text(
    hjust = 0.5, face = "italic", color = "darkcyan")
)
x_axis_theme <- element_text(size = 14)
```


```{r settings}


compare_countries <- c("Austria", "France", "Germany", "Italy", "India",
                       "South Korea", "Spain", "EU", "United States of America")
countries <- c("China", compare_countries)
countries_exp_growth <- c("World", "China", "Austria", "France", "Germany", "Italy", 
                       "South Korea", "Spain", "EU",  "United States of America")
country_select <- "Germany"

span <- 7 #  for rolling mean over 7 days
q <- floor(span/2) # since 2q +1 = span !

range_reg_short <- 7 # days; at least one week is necessary to get rid of weekly 
    # fluctuations, important - no case values = 0 are allowed => log(0) = inf !
range_reg_long <- 21 # days; 2 or 3 weeks if one week is to short
                           # e.g. confidence levels to large !!
# whole week is necessary to get rid of weekly fluctuations
range_forcast <- 14  # 14days forecast => unclass(last_date + 1 + range_forcast -1)

range_cfr <- 14  # 14days cfr past period length
lag_n <- 12  # average lag for confirmed -> death - for all countries

```


```{r path on desktop PC, eval = TRUE}

corona_confirmed <- 
  read_csv(paste0(data_path, "/time_series_covid19_confirmed_global.csv")) %>%
  mutate(Case_Type = "Confirmed")
corona_deaths <- 
  read_csv(paste0(data_path, "/time_series_covid19_deaths_global.csv"))  %>%
  mutate(Case_Type = "Deaths")
corona_recovered <- 
  read_csv(paste0(data_path, "/time_series_covid19_recovered_global.csv")) %>%
  mutate(Case_Type = "Recovered")
```


```{r read data bind rows and chanfge to long format}

corona_wide <- bind_rows(corona_confirmed, corona_deaths, corona_recovered)

corona <- corona_wide  %>%
    pivot_longer(cols = c(-`Province/State`, -`Country/Region`, -Case_Type, 
                          -Lat,  -Long ), 
                 names_to = c("Date"),
                 values_to = "Cases")

corona %<>% mutate(Date = as.Date(Date, format = "%m/%d/%y")) %>% 
  rename(Country = `Country/Region`) 

```


```{r data clean-up}

# clean-up column names
# corona %>% janitor::clean_names()

# clean-up names of column Country / denmark "regions" to country 
# same country names for covid-19 data and population_countries are needed
# names have to fit to names used by
# https://code.highcharts.com/mapdata/ => 
# World with Palestine areas, high resolution Demo  => Highmaps basic demo
corona %<>% mutate(
  Country = case_when(
  Country == "Burma" ~ "Myanmar",
  Country == "Mainland China" ~ "China",
  Country == "Czechia" ~ "Czech Republic",
  Country == "Denmark" & `Province/State` == "Greenland" ~ "Greenland",
  Country == "Denmark" & `Province/State` == "Faroe Islands" ~ "Faroe Islands",
  Country == "Guinea-Bissau" ~ "Guinea Bissau",
  Country == "Hong Kong SAR" ~ "Hong Kong",
  Country == "Holy See" ~ "Holy See (Vatican City)",
  Country == "Iran (Islamic Republic of)" ~ "Iran",
  Country == "Macao SAR" ~ "Macao",
  Country == "occupied Palestinian territory" ~ "Palestine",
  Country == "Republic of Korea" ~ "South Korea",
  Country == "Cote d'Ivoire" ~ "Ivory Coast",
  Country == "Congo (Brazzaville)" ~ "Republic of Congo",
  Country == "Congo (Kinshasa)" ~ "Democratic Republic of the Congo",
  Country == "Korea, South" ~ "South Korea",
  Country == "Serbia" ~ "Republic of Serbia",
  Country == "North Macedonia" ~ "Macedonia",
  Country == "Eswatini" ~ "Swaziland",
  Country == "Taiwan*" ~ "Taiwan",
  Country == "Tanzania" ~ "United Republic of Tanzania",
  Country == "US" ~ "United States of America",
  Country == "Viet Nam" ~ "Vietnam",
  TRUE ~ as.character(Country)))

# clean-up content of column `Province/State`
# replace NAs by Country
# replace "Bavaria"  by  Country since `Province/State` exists only until 
# end of January, as begin of February inluded in "Germany" data
# `Province/State` == "Bavaria" ~ Country, not needed in time series format,
#  needed for data file: covid_19_data.csv
corona %<>% mutate(    
  `Province/State` = case_when(
    is.na(`Province/State`) ~ Country,
    TRUE ~ `Province/State`)) %>% 
  arrange(Country, `Province/State`) %>% 
  group_by(Case_Type, Country, `Province/State`)

# View(corona %>% filter(Date == last_date & Case_Type == "Confirmed"))
```


```{r provinces data to country and add country world}
# add all data from provinces to country data 
corona_country <- corona %>% 
  group_by(Country, Date, Case_Type) %>% 
  summarise(Cases = sum(Cases, na.rm = TRUE))
corona_country %<>% 
  group_by(Country, Case_Type) %>% 
  mutate(Daily_Cases = c(NA, diff(Cases)))

# without Case_Type "Recovered"  - no real value add, no consistent data
corona_country %<>% filter(Case_Type != "Recovered")

first_date <- min(corona_country$Date)
last_date <- max(corona_country$Date)

# View(corona_country %>% filter(Date == last_date & Case_Type == "Confirmed"))
```

```{r add country World}

### provide sum of all countries as country "World" data
# for sum( , na.rm = TRUE) removing missing values is important,
# otherwise one region with NA (no cases) resulty in NA worldwide
corona_country_sum <- corona_country %>% 
  group_by(Date, Case_Type) %>% 
  summarise(Cases = sum(Cases, na.rm = TRUE))
corona_country_sum %<>% 
  group_by(Case_Type) %>% 
  mutate(Daily_Cases = c(NA, diff(Cases)),
         Country = "World")

corona_country <- bind_rows(corona_country, corona_country_sum)

```


```{r add country EU}
### provide sum of all EU countries as country "EU" data

countries_eu <- c("Austria", "Belgium", "Bulgaria", "Croatia", "Cyprus",
                  "Czech Republic", "Denmark", "Estonia", "Finland", "France",
                  "Germany", "Greece", "Hungary", "Ireland", "Italy",
                  "Latvia", "Lithuania", "Luxembourg", "Malta", "Netherlands",
                  "Poland", "Portugal", "Slovakia", "Slovenia", "Spain",
                  "Sweden")   

corona_country_sum <- corona_country %>% 
  filter(Country %in% countries_eu) %>% 
  group_by(Date, Case_Type) %>% 
  summarise(Cases = sum(Cases, na.rm = TRUE))
corona_country_sum %<>% 
  group_by(Case_Type) %>% 
  mutate(Daily_Cases = c(NA, diff(Cases)),
         Country = "EU")

corona_country <- bind_rows(corona_country, corona_country_sum)

```



```{r add population per country to data}

# add world population and normalize Confirmed and Deaths per 100k inhabitants

population_countries <- population_countries %>%
  dplyr::select(Country, Population)
# note: delects Type which provides split "Country" vs. "Region" for World & EU

corona_data <- full_join(corona_country, population_countries) 

corona_data %<>% filter(!is.na(Date)) %>% 
  mutate(Cases_100k = round(Cases/(Population/100000), digits = 1),
         Daily_Cases_100k = round(Daily_Cases/(Population/100000), digits = 2))

```

```{r add rolling mean  per country to data}

# slide_dbl() => rolling mean double value, changed to before only
#                             no longer centered with .before = .after
# note: for last date rolling mean before is needed, otherwise all are NA
corona_data %<>% 
  group_by(Country, Case_Type) %>% 
  mutate(Daily_Cases_Mean =  round(
    slider::slide_dbl(Daily_Cases,  ~ mean(.),
                      .before = 2*q, .after = 0, .complete = TRUE),
    digits = 1),
    Daily_Cases_100k_Mean = round(
      slider::slide_dbl(Daily_Cases_100k,  ~ mean(.), 
                        .before = 2*q, .after = 0, .complete = TRUE),
      digits = 2))

corona_tsbl <- corona_data  %>%
  tsibble::as_tsibble(index = Date, key = c(Country, Case_Type))

```


```{r}
saveRDS(corona_data, "corona_data.RDS")

# corona_data <- readRDS("corona_data.RDS")

```


```{r complete data wide format}
# wide format: 
#    Country Population Date  Confirmed Daily_Conf ... Death ...
# for easy to read datatable outputs e.g.with filter for last date
# 


# library(checkmate)

corona_data_wide <- get_corona_data_wide(corona_data)
# corona_data_wide <- corona_data %>% 
#   pivot_wider(names_from = Case_Type, 
#               values_from = c(Cases, Daily_Cases, 
#                               Cases_100k, Daily_Cases_100k, 
#                               Daily_Cases_Mean, Daily_Cases_100k_Mean)) %>% 
#   rename(Confirmed = Cases_Confirmed,
#          Deaths = Cases_Deaths,
#          Daily_Conf = Daily_Cases_Confirmed,
#          Daily_Deaths = Daily_Cases_Deaths,
#          Conf_100k = Cases_100k_Confirmed,
#          Deaths_100k = Cases_100k_Deaths,
#          Daily_Conf_100k = Daily_Cases_100k_Confirmed,
#          Daily_Deaths_100k = Daily_Cases_100k_Deaths,
#          Daily_Conf_Mean = Daily_Cases_Mean_Confirmed, 
#          Daily_Deaths_Mean = Daily_Cases_Mean_Deaths,
#          Daily_Conf_100k_Mean = Daily_Cases_100k_Mean_Confirmed, 
#          Daily_Deaths_100k_Mean = Daily_Cases_100k_Mean_Deaths) %>% 
#   dplyr::select(Country, Population, Date, 
#                 Confirmed, Daily_Conf, Daily_Conf_Mean, Conf_100k, 
#                 Daily_Conf_100k, Daily_Conf_100k_Mean, 
#                 Deaths, Daily_Deaths, Daily_Deaths_Mean, Deaths_100k, 
#                 Daily_Deaths_100k, Daily_Deaths_100k_Mean)

# View(corona_data_wide %>% filter(Date == last_date))
```

```{r}




```

```{r}
corona_data_last_wide <- corona_data_wide %>%
  filter(Date == last_date)

# corona_country_last <- corona_country %>%  filter(Date == last_date)
corona_data_last <- corona_data %>%
  filter(Date == last_date)


corona_last_abs_wide <- corona_data_last_wide %>% 
  dplyr::select(!contains("_100k"), -Population)

corona_last_rel_wide <- corona_data_last_wide %>% 
  dplyr::select(Country, Date, contains("_100k"))
```



World Map {data-navmenu="World Map"}
=====================================  

***
***

<center>**Spread of Coronavirus SARS-CoV-2**</center>

**World Map with Confirmed and Death Cases** (Data source [[@JHU2020a]](#bib), see also [[@JHU2020]](#bib))  

### Total Confirmed for each Country

```{r World Map Confirmed}
# see https://code.highcharts.com/mapdata/

# plot total confirmed in world
i <- "Confirmed"
title <- paste(i, "- Cumulated Cases / Country")
world_map_plot(
  filter(corona_data_last, Case_Type == i & Country != "World"), 
  i, value = "Cases", title)

```


### Total Deaths for each Country

```{r World Map Deaths}

# plot total deaths in world
i <- "Deaths"
title <- paste(i, "- Cumulated Cases / Country")
world_map_plot(
  filter(corona_data_last, Case_Type == i & Country != "World"), 
  i, value = "Cases", title)

```


World Map / Inhabitants {data-navmenu="World Map"}
=====================================

<center>**Spread of Coronavirus SARS-CoV-2**</center>

**World Map with Confirmed and Death Cases** (Data source [[@JHU2020a]](#bib), see also [[@JHU2020]](#bib))  

### Total Confirmed for each Country per 100,000 Inhabitants

```{r World Map Confirmed per 100k Inhabitants}
# see https://code.highcharts.com/mapdata/

# plot total confirmed in world
i <- "Confirmed"
title <- paste(i, "- Cumulated Cases per 100k Inhabitants / Country")
world_map_plot(
  filter(corona_data_last, Case_Type == i & Country != "World"), 
  i, value = "Cases_100k", title)

```


### Total Deaths for each Country per 100,000 Inhabitants

```{r World Map Deaths per 100k Inhabitants}

# plot total deaths in world
i <- "Deaths"
title <- paste(i, "- Cumulated Cases per 100k Inhabitants / Country")
world_map_plot(
  filter(corona_data_last, Case_Type == i & Country != "World"), 
  i, value = "Cases_100k", title)

```



World Map / Hot Spots {data-navmenu="World Map"}
=====================================

<center>**Spread of Coronavirus SARS-CoV-2**</center>

**World Map with mean Confirmed and Death Cases over the past seven days** (Data source [[@JHU2020a]](#bib), see also [[@JHU2020]](#bib))  

### Mean Confirmed Cases for each Country per 100,000 Inhabitants

```{r World Map Mean Confirmed per 100k Inhabitants}
# see https://code.highcharts.com/mapdata/

# plot total confirmed in world
i <- "Confirmed"
title <- 
  paste(i, 
        "- Mean Daily Cases per 100k Inhabitants / Country over the past seven days")
world_map_plot(
  filter(corona_data_last, Case_Type == i & Country != "World"), 
  i, value = "Daily_Cases_100k_Mean", title)

```


### Mean Death Cases for each Country per 100,000 Inhabitants

```{r World Map Mean Deaths per 100k Inhabitants}

# plot total deaths in world
i <- "Deaths"
title <- 
  paste(i, 
        "- Mean Daily Cases per 100k Inhabitants / Country over the past seven days")
world_map_plot(
  filter(corona_data_last, Case_Type == i & Country != "World"), 
  i, value = "Daily_Cases_100k_Mean", title)

```


Bar Chart {data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Column {data-width=300}
-------------------------------------

### Bar Chart Cumulated Confirmed

```{r Top Ten Bar Chart Confirmed}

# plot bar chart deaths / country
i <- "Confirmed"
bar_chart_countries(filter(corona_data_last,
                           Country != "World" & Case_Type == i), i)

```

### Bar Chart Cumulated Deaths

```{r Top Ten Bar Chart Deaths}

# plot bar chart deaths / country
i <- "Deaths"
bar_chart_countries(filter(corona_data_last,
                           Country != "World" & Case_Type == i), i)

# include comment
```


Column
-------------------------------------

### Confirmed and Deaths - Cumulated and Daily Cases (absolute date)

Case numbers are taken from [[@JHU2020a]](#bib). In order to compensate for the 
daily fluctuations, the mean case numbers for the past seven days (*_Mean) were also added.

```{r print datatable in wide format}

scroll_y <- "700px"
DT::datatable(corona_last_abs_wide, 
              options = list(pageLength = 50, scrollY=scroll_y))

```


Bar Chart / Inhabitants {data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Column {data-width=300}
-------------------------------------

### Bar Chart Cumulated Confirmed per 100,000 Inhabitants

```{r Top 20 Bar Chart Population Confirmed}

# plot bar chart Confirmed / 100k for countries and + world
i <- "Confirmed"
bar_chart_countries_pop(filter(corona_data_last, Case_Type == i), i)

```


### Bar Chart Cumulated Deaths per 100,000 Inhabitants

```{r Top 20 Bar Chart Population Deaths}

# plot bar chart deaths / country
i <- "Deaths"
bar_chart_countries_pop(filter(corona_data_last, Case_Type == i), i)

```

Column
-------------------------------------

### Confirmed and Deaths - Cumulated and Daily Cases per 100,000 Inhabitants (relative date)

Population numbers are taken from [[@UNO2020]](#bib).
In order to compensate for the daily fluctuations, the mean case numbers for the past seven days (*_Mean) were also added.

```{r print datatable 100k in wide format}

DT::datatable(corona_last_rel_wide, 
              options = list(pageLength = 50, scrollY=scroll_y))

```

Bar Chart / Hot Spots {data-navmenu="Bar Chart"}
=====================================

***
***
  
**Bar Charts with descending order**

Column {data-width=300}
-------------------------------------

### Bar Chart Mean Confirmed per 100,000 Inhabitants over past seven days

```{r Top 20 Mean Bar Chart Population Confirmed}

# plot bar chart mean Confirmed / 100k for countries and + world
i <- "Confirmed"
bar_chart_countries_hot_spots(filter(corona_data_last, Case_Type == i), i) 
                      #  value = "Daily_Cases_100k_Mean")

```


### Bar Chart Mean Deaths per 100,000 Inhabitants over past seven days

```{r Top 20 Mean Bar Chart Population Deaths}

# plot bar chart deaths / country
i <- "Deaths"
bar_chart_countries_hot_spots(filter(corona_data_last, Case_Type == i), i)
                        # value = "Daily_Cases_100k_Mean")

```

Column
-------------------------------------

### Confirmed and Deaths - Cumulated and Daily Cases per 100,000 Inhabitants (relative date)

Population numbers are taken from [[@UNO2020]](#bib).
In order to compensate for the daily fluctuations, the mean case numbers for the past seven days (*_Mean) were also added.

```{r print mean datatable 100k in wide format}

DT::datatable(corona_last_rel_wide,
              options = list(pageLength = 50, scrollY=scroll_y))

```

Bar Chart - CFR {data-navmenu="Bar Chart" #cfr}
=====================================

***
***
  
**Bar Chart with descending order**

Column {data-width=300}
-------------------------------------

### Bar Chart CFR Total - Case Fatality Rate (in %)

```{r calculate lagged CFR}

corona_confirmed_lag <- corona_data_wide %>% 
  dplyr::select(!contains("_100k"), -Population, 
                -Daily_Conf, -Daily_Deaths) %>% 
  mutate(confirmed_lag = lag(Confirmed, lag_n),
         CFR_total = round(Deaths / confirmed_lag * 100, digits = 1),
         CFR_unlagged = round(Deaths / Confirmed * 100, digits = 1)) 

corona_total_CFR_lag <- corona_confirmed_lag %>% 
  filter(Date == last_date) 



corona_before <- corona_confirmed_lag %>% 
  filter(Date == last_date - range_cfr + 1) %>% 
  mutate(Deaths_before = Deaths,
         confirmed_lag_before = confirmed_lag) %>% 
  select(Country, Deaths_before, confirmed_lag_before )


cfr_table <- left_join(corona_total_CFR_lag, corona_before) %>% 
  mutate(confirmed_past_period = confirmed_lag - confirmed_lag_before,
         deaths_past_period = Deaths - Deaths_before,
         CFR_past_period = round(
           deaths_past_period / confirmed_past_period * 100, digits = 1)) %>% 
  select(Country, CFR_total, CFR_past_period, CFR_unlagged)

```


```{r Top 20 Bar Chart CFR}

# Visualization with top 10 country - CFR  bar chart
bar_chart_cfr <- function(data, i) {
  data %>%
    arrange(desc(CFR_total)) %>% 
    head(20) %>%
    hchart("bar",hcaes(x = Country,  y = CFR_total)) %>%
    hc_title(text = paste(i, "- Case Fatality Rate (in %)")) %>% 
    hc_add_theme(hc_theme_sandsignika())
}


# plot bar chart Confirmed - CFR countries and + world
i <- "CFR_total"
bar_chart_cfr(cfr_table, i)

```

### Bar Chart CFR Total (in %) - - selected countries {data-height=200}


```{r Top 20 Bar Chart CFR selected countries}

# Visualization with top 10 country - CFR  bar chart
bar_chart_cfr <- function(data, i) {
  data %>%
    arrange(desc(CFR_total)) %>% 
    head(25) %>%
    hchart("bar",hcaes(x = Country,  y = CFR_total)) %>%
    hc_title(text = paste(i, "- Case Fatality Rate (in %)")) %>% 
    hc_add_theme(hc_theme_sandsignika())
}


# plot bar chart Confirmed - CFR countries and + world
i <- "CFR_total"
bar_chart_cfr(filter(cfr_table, Country %in% compare_countries), i)

```

Column  
-------------------------------------

### Case Fatality Rate - Proportion of deaths from confirmed cases {data-height=170}

The number of confirmed cases is an early predictor of the number of deaths.
The number of today's deaths is already determined by the infections about by 
$\sim19$ days ago or respectively by the confirmed cases about by $\sim11$ days 
ago [[see @RWI2020]](#bib).

An average duration of *Confirmed Infection to Death* of $12$ (lag-)days 
(country-independent for the sake of simplicity) is assumed for the calculations, 
since many tests are carried out in the meantime before symptoms appear.

However, this varies considerably depending on country-specific test rate and 
health system. In the worst health systems it is only one day for recognized 
cases, the "Confirmed" cases must be "lagged" by $\sim1$ day. 
In the best case, the time from the end of incubation period (in average $\sim5-6$ days) to death is an average $\sim19$ days. In this case, the average 
*Confirmed infection to Death* period is $\sim14$ days), the "Confirmed" cases
must be correctly "lagged" by $\sim14$ days.
For the assumed time periods see [[@RKI2020a]](#bib), [[@RKI2020b]](#bib), for Case Fatality Rate 
and Incubation Period in general see [[@Wikipedia2020a]](#bib),
[[@Wikipedia2020b]](#bib).

The simple calculation with unlagged cumulated confirmed cases divided by
cumulated deaths results in a significant underestimation of the CFR in health systems with early disease detection. 
If the number of cumulative cases is already large compared to the number of 
active cases (~ cases from the past two weeks), the "lagged" rsp. "unlagged"
values converge.

The Infection Fatality Rate (IFR) is the fatality rate of all infection, that means
detected confirmed cases and undetected cases (asymptomatic and not tested group).
This lethality is assumed to 
be country independent and only rough estimates exist (RKI: bottom of existing estimates $\sim0.56\%$). 


```{r CFR Table}

title <- paste("Case Fatality Rate in %", "- CFR_total and CFR_past_period (period of past", 
               range_cfr, "days) w/ Confirmed lagged by", lag_n, "days")
# knitr::kable(cfr_table,
#              digits = 2, caption = title)

```

### `r title` {data-height=430}

```{r}

DT::datatable(cfr_table,  
              options = list(pageLength = 25, scrollY = "300px"))

```

### Case Fatality Rate (in %) - selected countries {data-height=200}


```{r CFR Table selected countries}

knitr::kable(filter(cfr_table, Country %in% compare_countries), digits = 2)

```


Countries - Table overview {data-navmenu="Bar Chart"}
=====================================

**Countries - Table overview**

Column
-------------------------------------

### Confirmed and Deaths - Cumulated and mean daily Cases, overall and per 100,000 Inhabitants (absolute and relative date)

Population numbers are taken from [[@UNO2020]](#bib).
In order to compensate for daily fluctuations, the mean number of cases for the 
past seven days (*_Mean) is used instead of the daily cases.

```{r print datatable all with 100k in wide format}

# DT::datatable(corona_data_last %>% filter(Case_Type != "Recovered"),
#               options=list(pageLength=25))

DT::datatable(
  corona_data_last_wide %>% 
    mutate("Population /m" = round(Population / 1000000, digits = 3)) %>% 
    dplyr::select(
      Country, `Population /m`, Date, 
      Confirmed, Daily_Conf_Mean, Conf_100k, Daily_Conf_100k_Mean,
      Deaths, Daily_Deaths_Mean, Deaths_100k, Daily_Deaths_100k_Mean), 
  options = list(pageLength = 50, scrollY=scroll_y))

```

EU - Table overview {data-navmenu="Bar Chart"}
=====================================

**European Union - Table overview**

Column
-------------------------------------

### Confirmed and Deaths - Cumulated and mean daily Cases, overall and per 100,000 Inhabitants (absolute and relative date)

Population numbers are taken from [[@UNO2020]](#bib).
In order to compensate for daily fluctuations, the mean number of cases for the 
past seven days (*_Mean) is used instead of the daily cases.

```{r print datatable EU with 100k in wide format}

# DT::datatable(corona_data_last %>% filter(Case_Type != "Recovered"),
#               options=list(pageLength=25))

DT::datatable(
  corona_data_last_wide %>% 
    filter(Country %in% c(countries_eu, "EU")) %>% 
    mutate("Population /m" = round(Population / 1000000, digits = 3)) %>% 
    dplyr::select(
      Country, `Population /m`, Date, 
      Confirmed, Daily_Conf_Mean, Conf_100k, Daily_Conf_100k_Mean,
      Deaths, Daily_Deaths_Mean, Deaths_100k, Daily_Deaths_100k_Mean), 
  options = list(pageLength = 50, scrollY=scroll_y))

```



Cumulated and Daily Trend {data-orientation=rows data-navmenu="Cumulated and Daily Trend" }
=====================================

***
***


```{r}

fig_width_trend <- 10 # fig.width = fig_width_trend 7
fig_asp_trend <- 0.35

weeks <- 12

```


**Cumulated and Daily Cases over Time**  

Row {data-height=400}
------------------------------------

```{r}
country <- "World"
```

### `r country`

```{r  Trend Cum and Daily World, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

ggts_cum_daily(corona_data, country = country, weeks = weeks)

# providing same plots but with *_100k data (=> same figure with new y-scale)
# ggts_cum_daily(corona_data, 
#                y_cum = Cases_100k, y_daily = Daily_Cases_100k, 
#                daily_mean = Daily_Cases_100k_Mean,
#                country = country, weeks = weeks)
```

Row {.tabset .tabset-fade}
------------------------------------

**Selected Countries**

```{r}
i <- 1
```


### `r countries[i]` 
```{r  Trend Cum and Daily Country 1, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 2, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 3, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 4, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 5, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 6, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 7, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 8, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 9, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

### `r countries[i]` 
```{r  Trend Cum and Daily Country 10, fig.width = fig_width_trend, fig.asp = fig_asp_trend}

country <- countries[i]
ggts_cum_daily(corona_data, country = country, weeks = weeks)
i <- i + 1
```

Reproduction Number {data-orientation=rows data-navmenu="Cumulated and Daily Trend"}
=====================================

***
***

**`r country_select` - Rolling Mean and Reproduction Number**  

Row {data-height=400}
------------------------------------

### `r country_select` Rolling Mean of Daily Cases  



```{r dygraph_plot country_select in addition, eval = TRUE}

### Germany - Confirmed and Deaths

data <- corona_data_wide %>% 
  dplyr::select(!contains("_100k"), -Population) %>% 
  filter(Country == country_select) 


```

```{r dygraph_plot Daily Rolling Mean}


# change tibble in xts object
index <- data$Date
data  %<>% ungroup() %>% select(-Country, -Date) 


# data_xts <- xts::xts(
#   data %>% dplyr::select(Confirmed, Deaths, Daily_Conf, Daily_Deaths), 
#   order.by = index)
# 
# 
# plot_dygraph_all(data_xts, country_select, last_date)


data_xts <- xts::xts(
  data %>% dplyr::select(Daily_Conf, Daily_Conf_Mean, 
                         Daily_Deaths, Daily_Deaths_Mean),
  order.by = index)
plot_dygraph_daily(data_xts, country_select, last_date, weeks = weeks)


```

### Rolling Mean of Daily Cases {data-width=300} 

The *7-day Rolling Mean/Moving Average* of the Daily Confirmed and Death Cases 
smooths out the short-term weekly fluctuations (weekend).

The daily confirmed cases are related to the left y-axes, the daily death cases 
are related to the right y-axes. This clearly outlines the 12 days delay relation between daily confirmed and death cases and also  the roughly the factor 
of ~1/25 (~4%).






Row {data-height=400}
------------------------------------

### `r country_select` Calculated Reproduction Number  


```{r dygraph_plot Reproduction Number Rolling Mean, eval = TRUE}


# infectivity profile w(t) w/ w(t= day_1 & day>=11)=0:
infectivity <- c((0:3)/3, 1, (5:0)/5)
names(infectivity) <- seq_along(infectivity)
infectivity <- infectivity / sum(infectivity)

width <- 7         #  => window (rolling mean one sided) in repronum() 
report.delay <- 7  #  => delay (reporting delay) in repronum() 
alpha <- 0.05      # => default conf.level in repronum() 


data_repronum <- corona_data_wide %>% 
  filter(Country == country_select) %>% 
  dplyr::select(Country, Date, Daily_Conf, Daily_Conf_Mean) %>% 
  ungroup() 

repronum_output <- repronum(new.cases = data_repronum$Daily_Conf, 
                            profile = infectivity, 
                            window = width,
                            delay = report.delay)

data_repronum  <- bind_cols(data_repronum, repronum_output) %>% 
  rename(Repro_number = repronum)


# change tibble in xts object
index <- data_repronum$Date
data_repronum  %<>% select(-Country, -Date, -repronum.se) 


data_xts <- xts::xts(data_repronum, order.by = index)

plot_dygraph_daily_repro(data_xts, country_select, last_date, weeks = weeks)


```


### Calculated Reproduction Number {data-width=300} 

The calculation of the  **reproduction number** $R(t)$ uses 
a R function provided by [[@Hotz2020]](#bib) on GitHub. 

The (effective) **reproduction number** $R(t)$ at day $t$, 
i.e. the average number of people someone infected at time $t$ would infect 
if conditions remained the same. 

For further 
German federal states figures (based on the data provided by Robert Koch Institut) see [[@Hotz2020a]](#bib) and for
worldwide figures  (based on the data provided by Johns Hopkins University) see [[@Hotz2020b]](#bib).


For the calculation the assumption of 7-days reporting delay 
(confirmed is reported 7-days after 'real' infection) is unchanged and the same
modelled infectivity profile *w* is used.
The lower and upper confidence interval lines provide the (approximate, pointwise) 
**95% confidence interval** (only based on statistical numbers, possible changes 
in e.g. counting measures can not be considered). 

This is the reason why [[@Hotz2020]](#bib) "do not compute an average over a 
sliding window of seven days so the viewer immediately recognizes the size of such
artefacts, warning her to be overly confident in the results. In fact, these artefacts are much larger than the statistical uncertainty due to the stochastic nature of the epidemic which is reflected in the confidence intervals."

Nevertheless, here the calculation is based on the 7-days rolling mean and therefore
the figure smooths over the the weekly rhythm.


Virus Spread on log10 scale {data-navmenu="Exp Linear Growth"}
=====================================

***
***


Column {data-width=100}
-------------------------------------

### Exponential Growth Evaluation

China and South Korea slowed down exponential growth significantly at an early stage. Their lines in the diagram with the log10 scale have therefore no longer 
had a significant slope.
 
In early phases countries have a more or less unchecked exponential
growth. 
If countermeasures are effective, reduced exponential growth is reflected in a 
reduced slope of the accumulated cases again.

Column
-------------------------------------

### Virus Spread with log10 scale (since mid of Jan)

```{r}

labels_scale <- c(10, 100, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 
                  5000000, 10000000)

```


```{r plot log10scale w/o date filter, fig.width = 14, fig.asp = 0.8}

# logscale plot w/o date filter
data <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in%  c("World", "China", compare_countries) & 
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

gg_plot <- gg_logscale(data)
  
plot_1 <- gg_plot + 
  scale_y_continuous(breaks = log10(labels_scale), label = labels_scale) +
  geom_line(aes(col = Country), size = 0.5) +
  labs(title = "Cumulated Cases") +
  facet_wrap(vars(Case_Type), ncol = 1, scales = "free_y",
             strip.position = "left")

##  plot per 100,000 inhabitants
data <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in%  c("World", "China", compare_countries) & 
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases_100k)

gg_plot <- gg_logscale(data, x = Date, y = Cases_100k)
  
plot_2 <- gg_plot + 
  scale_y_continuous(breaks = log10(labels_scale), label = labels_scale) +
  geom_line(aes(col = Country), size = 0.5) +
  labs(title = "Cumulated Cases / 100k Inhabitants",
       y = "Cumulated Cases / 100k Inhabitants") +
  facet_wrap(vars(Case_Type), ncol = 1, scales = "free_y",
             strip.position = "left") 


plot_1 + plot_2 + 
  plot_annotation(
    title = "Virus Spread - World and selected Countries") +
  plot_layout(guides = 'collect') & theme(legend.position = 'bottom')

```



```{r plot per inhabitants with log10scale, eval = FALSE, fig.width = 7, fig.asp = 1.5}
# Column
# -------------------------------------
# 
# ### Virus Spread / Inhabitants with log10 scale (since mid of Jan)

# Virus Spread / 100,000 Inhabitantson on log10 scale (since mid of Jan)

data <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in%  c("World", "China", compare_countries) & 
           Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases_100k)

gg_plot <- gg_logscale(data, x = Date, y = Cases_100k)
  
gg_plot + 
  scale_y_continuous(breaks = log10(labels_scale), label = labels_scale) +
  geom_line(aes(col = Country), size = 0.5) +
  labs(subtitle = paste("Since", first_date),
       y = "Cumulated Cases / 100k Inhabitants",
       title = "Virus Spread / 100,000 Inhabitants (with log10 scale)") +
  facet_wrap(vars(Case_Type), ncol = 1, scales = "free_y",
             strip.position = "left") 

```

Exponential Growth {data-navmenu="Exp Linear Growth"}
=====================================

***
***

Column {data-width=400}
------------------------------------  

### Estimation spread of the Coronavirus with Linear Regression of log data

**Exponential Growth and Doubling Time $T$**

Exponential growth over time can be fitted by linear regression if the logarithms
of the case numbers is taken. Generally, exponential growth corresponds to
linearly growth over time for the log (to any base) data 
[[see also @Wikipedia2020]](#bib). 

The semi-logorithmic plot with base-10 log scale for the Y axis shows 
functions following an exponential law $y(t) = y_0 * a^{t/\tau}$
as straight lines. The time constant $\tau$ describes the time required for y to increase by one factor of $a$. 

If e.g. the confirmed or death cases are growing in $t-days$ by a factor of $10$
the doubling time $T \widehat{=} \tau$ can be calculated with $a \widehat{=} 2$ by

<p style="text-align: center;">
$T[days] = \frac {t[days] * log_{10}(2)} {log_{10}(y(t))-log_{10}(y_0)}$
</p>

with    
<p style="text-align: center;">
$log_{10}(y(t))-log_{10}(y_0) = = log_{10}(y(t))/y_0) = log_{10}(10*y_0/y_0) = 1$  
</p>

and doubling time   
<p style="text-align: center;">
$T[days] = t[days] * log_{10}(2) \approx t[days] * 0.30$.
</p>

For Spain, Italy, Germany we have had a doubling time of only $T \approx 9days * 0.3 \approx 2.7 days$ at the beginning of the pandemic!!. 

The *doubling time $T$* and the *Forecast* is calculated for following
selected countries: **`r compare_countries`** and **World** in total 
(see [Forecast / Doubling Time](#doubling)).


### `r country_select` - Trend with Forecast on a linear scale


```{r corona tsibble range_reg_short}


# provide tsbl of range_reg_short for linear regression of log data
corona_range_reg_short_tsbl <- corona_tsbl %>% 
  group_by(Case_Type) %>% 
  filter(Country %in% c("World", compare_countries) & 
           Date >= last_date - range_reg_short + 1) %>% 
           # Case_Type != "Recovered" & Cases >= 10) %>% 
  dplyr::select(Date, Country, Case_Type, Cases)



```

```{r corona tsibble range_reg_long}

# provide tsbl of range_reg_long for linear regression of daily log data

corona_range_reg_long_tsbl <- corona_tsbl %>% 
  group_by(Case_Type) %>% 
  filter(Country %in% c("World", compare_countries) & 
           Date >= last_date + 1 - range_reg_long) 

```


```{r example, fig.width = 10, fig.height = 5}


fit_corona <- corona_range_reg_long_tsbl %>%  
  model(TSLM(log(Daily_Cases_Mean) ~ Date)) 
fc_corona <- fit_corona %>% 
  fabletools::forecast(h = "14 days") 

fc_corona %>%  
  filter(Country == country_select) %>% 
  autoplot(corona_range_reg_long_tsbl) +
  ggtitle(paste(country_select, "- Cases and 14-days Forecast (linear y-scale)"),
          subtitle = paste(
            "Forecast is based on regression of past ",
            range_reg_long, " days")) +
  labs(x = "Days") +
  # scale_y_log10() +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")


```


### Forecast Plot - next `r range_forcast` days {data-height=150}

The plot shows the daily cases forecast increase in case of unchecked 
exponential growth. 
The dark shaded regions show the 80% rsp. 95% prediction intervals. 
These prediction intervals are displaying the uncertainty in forecasts 
based on the linear regression of the logarithmic data over the past
`r range_reg_long` days.

Column {data-width=600}
------------------------------------ 

### Comparison Exponential Growth (Daily rolling mean cases on log10 scale)


```{r plot log10scale selected Country}

# gg_plot <- gg_logscale(corona_tsbl_range_reg)  +
#   geom_smooth(method="lm", aes(col = Country), lty = "dashed", se=FALSE)
gg_plot <- gg_logscale(corona_range_reg_long_tsbl, y = Daily_Cases_Mean)  +
  geom_smooth(method="lm", aes(col = Country), lty = "dashed", se=FALSE)
  
gg_plot +
  scale_y_continuous(breaks = log10(labels_scale), label = labels_scale) +
  labs(subtitle = paste("Past", range_reg_long, "days with Linear Regression of log data"))
                # changed from: range_reg
```



### Germany - Cumulated cases with ~linear slope on a log10 scale {data-height=400}

```{r  Plot with Linear Regression}
# plot with linear regression on log scale
# linear regression of the logarithmic data for the past seven days
# 
for (i in country_select) { 
  plot_cases <- 
    ggts_trend_facet(corona_data %>% filter(Country == i & Cases >= 10)) +
    labs(title = paste(i, "- Cumulated Cases")) +
    scale_y_log10()
  plot_cases_past_weeks <- 
    ggts_trend_facet(corona_data %>% filter(Country == i & Cases >= 10 &
                                                    Date >= last_date - 28 + 1)) +
    labs(title = paste(i, "- Cumulated Cases (past 28 days"), 
         subtitle = paste("w/ linear regression of log data for past", 
                          range_reg_short, "days"))  +
    geom_smooth(data = corona_data %>% 
                  filter(Country == i & Case_Type != "Recovered" & 
                           Date >= last_date + 1 - range_reg_short), 
                method="lm", 
                col = "black", size = 1, se = FALSE) +
    scale_y_log10() +
    scale_x_date(date_labels = "%b %d", date_breaks = "7 days")
  # gridExtra::grid.arrange(plot_cases, plot_daily_cases, ncol = 2)
  print(plot_cases + plot_cases_past_weeks) 
}

```

Compare Exp vs Linear Growth {data-navmenu="Exp Linear Growth"}
=====================================

***
***


Column {data-width=150}
-------------------------------------

### Comparison Exponential vs. Linear Growth

The charts compare the different forecasts for an exponential rsp. linear growth 
model. Due to the large fluctuations of the daily cases regression of three 
weeks is required. Otherwise the prediction levels are much too big.

The dark shaded regions are indicating the $80\%$ rsp. $95\%$  prediction 
intervals. These prediction intervals are displaying the "pure" statistical 
uncertainty in forecasts based on the regression models.

For doubling periods in the order of period of infectivity
(RKI assumption: $\sim9-10$ days, with great uncertainty, 
see [[@RKI2020b]](#bib), we no longer have exponential growth. 
The "old" infected cases are at the end of the doubling period no longer 
infectious (active). 
This results in a constant infection rate with basic reproduction number
$R_t \sim 1$ or even $<1$.

Note: for case numbers of German federal states see [[@RKI2020]](#bib).


Column
-------------------------------------
### Daily Rolling Mean Cases - Comparison Exponential and Linear Growth

```{r daily forecast linear model, fig.asp = fig_asp_trend}

forecast_range <- 7
forecast_days <- paste(forecast_range, "days")

fit_daily_corona <- corona_range_reg_long_tsbl %>%
  group_by(Case_Type) %>% 
  model(Exp_Growth = TSLM(log(Daily_Cases_Mean) ~ Date),
        Linear_Growth = TSLM(Daily_Cases_Mean ~ Date)) 

fc_daily_corona <- fit_daily_corona %>% 
  fabletools::forecast(h = forecast_days) 

fc_daily_corona %>%  
  filter(Country == country_select) %>% 
  autoplot(corona_range_reg_long_tsbl) +
  labs(title = paste(
    country_select, " - Forecast of Mean Daily Mean Cases for the next ", 
    forecast_range, "-days"),
    subtitle = paste(
      "Forecast is based on regression of past ",
      range_reg_long, " days")) +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```


### Cumulated Cases - Comparison Exponential and Linear Growth

```{r daily forecast exp growth, fig.asp = fig_asp_trend}

fit_cum_corona <- corona_range_reg_long_tsbl %>%
  group_by(Case_Type) %>% 
  model(Exp_Growth = TSLM(log(Cases) ~ Date),
        Linear_Growth = TSLM(Cases ~ Date)) 

fc_cum_corona <- fit_cum_corona %>% 
  fabletools::forecast(h = forecast_days) 


fc_cum_corona %>%  
  
  filter(Country == country_select) %>% 
  autoplot(corona_range_reg_long_tsbl) +
  labs(title = paste(
    country_select, " - Forecast of Cumulated Cases for the next ", 
    forecast_range, "-days"),
    subtitle = paste(
      "Forecast is based on regression of past ",
      range_reg_long, " days")) +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```



Doubling Time / Forecast Accuracy {data-navmenu="Forecast" #doubling}
=====================================

***
***

Column {data-width=500}
-------------------------------------

**Doubling Time and Forecast** 
The forecasted cases for the next 14 days are calculated 'only' from the
linear regression of the logarithmic data and are not considering any effects of 
measures in place. In addition data inaccuracies are not taken into account, 
especially relevant for the confirmed cases. 

Therefore the 14 days forecast is only an indication for the direction of an 
unchecked exponentiell growth.

The cumulated cases doubling rate is only a good indicator at the beginning of 
the pandemic. 
If the number of confirmed cases from the past two weeks is already small 
compared to the total number of confirmed cases, the number of infectious people 
is also small compared to the total cases.

Therefore the table below provides the doubling time for the 
daily rolling mean cases. The forecast is based on the linear regression of the 
logarithmic data of past `r range_reg_long` days.

```{r daily rolling mean cases forecast coef beta_0 and beta_1, eval = TRUE}

fit_corona <- corona_range_reg_long_tsbl %>%  
  model(TSLM(log(Daily_Cases_Mean) ~ Date)) 

coefs <- tidy(fit_corona) %>% 
  group_by(Country, Case_Type) %>% 
  mutate(T_doubling = (log(2) /estimate))

forecast_table <- coefs %>% 
  pivot_wider(id_cols = c(Country, Case_Type), 
              names_from = term, 
              values_from = estimate) %>% 
  group_by(Country, Case_Type) %>%
  rename(beta_0 = `(Intercept)`,
         beta_1 = Date) %>% 
  mutate(T_doubling = (log(2) / beta_1),
         Reg_last_day = exp(beta_0 + unclass(last_date) * beta_1),
         FC_next_day = exp(beta_0 + unclass(last_date + 1) * beta_1),
         FC_14days = exp(beta_0 + unclass(last_date + 1 + range_forcast-1) 
                         * beta_1)) %>% 
  arrange(Case_Type) %>% 
  select(Country, Case_Type, T_doubling, Reg_last_day, 
         FC_next_day, FC_14days)

knitr::kable(forecast_table,  digits = c(0, 0, 1, 0, 0),
             format.args = list(big.mark = "'"),
             caption = 
             "Forecast (FC) Daily Rolling Mean Cases: Doubling Time (days), 
             Forecasted cases next day/tomorrow and  Forecasted cases in 14 days")

```


Column
-----------------------------------------------------------------------  

### Forecast of Daily  and Cumulated Cases and check of Accuracy {data-height=250}

The forecast accuracy is checked by using the forecast method for the past 
three weeks before the past week (*training data*). Subsequent forecasting of the 
past week enables comparison with the real data of these days (*test data*).

The comparison is also an early indicator if the *exponential growth* is 
declining. However, possible changes in underreporting
(in particular the proportion confirmed / actually infected) requires careful 
interpretation.

For doubling periods of the total cumulated cases in the order of infectivity (RKI assumption: $\sim9-10$
days, with great uncertainty, [[see @RKI2020b]](#bib), we have no  
exponential growth for the total cumulated cases. Since the "old" infected cases are 
no longer infectious after these periods and we then have a constant infection 
rate with  basic reproduction number $R_t \sim 1$.

Instead, we have "only" linear growth of the cumulative *Confirmed Cases* and 
the *Daily Confirmed Cases* remain more or less constant if $R_t \sim 1$.

However, the basic reproduction number 
$R_0 (\approx 3.3 - 3.8)$ [[@RKI2020c]](#bib) is a product of the average number
of contacts of an infectious person per day, the probability of transmission upon contacts and the average number of days infected people are infectious. 
With the current uncertainty of the average duration of the infectivity duration, $R_0$ can therefore be estimated from the doubling time only to a very limited extent.
See also [[@CMMID2020]](#bib).

### Germany - Forecast Daily Rolling Mean Cases based on past `r range_reg_long` days {data-height=225}


```{r forecast daily exp model, fig.asp = fig_asp_trend}

fc_daily_corona %>%  
  filter(Country == country_select & .model == "Exp_Growth") %>% 
  autoplot(corona_range_reg_long_tsbl) +
  labs(title = paste(
    country_select, " - Forecast of Mean Daily Cases for the next ", 
    forecast_range, "-days"),
    subtitle = paste(
      "Forecast is based on regression of past ",
      range_reg_long, " days")) +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left")

```

```{r forecast check settings}
# Note: as long as zero deaths are in the training data time range 
# log(0) will go to infinity => no linear regression possible

# total = training + test_data => 
#    Date >= last_date + 1 - training_data_start = last training_data_start days

training_data_start <- range_reg_long +  forecast_range 
              # (last_date + 1) minus x days
forecast_days <- paste(forecast_range, "days")

corona_tsbl_train <- corona_tsbl %>% 
  group_by(Case_Type) %>% # since .add = FALSE will override existing groups
  filter(Country %in% country_select & 
           Date >= last_date + 1 - training_data_start &
           Date < last_date + 1 - forecast_range)

corona_tsbl_total <- corona_tsbl %>% 
  group_by(Case_Type) %>% 
  filter(Country %in% country_select  & 
           Date >= last_date + 1 -  training_data_start) 

```

### Germany - Forecast Accuracy Check Daily Rolling Mean Cases for the past `r forecast_range` days {data-height=225}

```{r daily forecast accuracy, fig.asp = fig_asp_trend}

fit_corona_train <- corona_tsbl_train %>% 
  model(TSLM(log(Daily_Cases_Mean) ~ Date)) 
fc_corona_train <- fit_corona_train %>% 
  fabletools::forecast(h = forecast_days) 

# forecasts accuracy
# for evaluating accuracy on forecasts to be provided:
# - a complete dataset that includes the future data and 
# - data used to train the model.

# level = prediction interval in % or NULL
fc_corona_train %>%
  autoplot(corona_tsbl_total) +
  labs(title = paste(
    country_select, "- Forecast based on regression of previous",
    range_reg_long, "days"),
    subtitle = "Forecast (blue line) vs. Data (black line)") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left") +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days")

```


```{r cumulated forecast accuracy, fig.asp = fig_asp_trend, eval = FALSE}
### Germany - Forecast Accuracy Check for the past `r forecast_range` days 
### for the Cumulated Cases {data-height=225}

fit_corona_train <- corona_tsbl_train %>% 
  model(TSLM(log(Cases) ~ Date)) 
fc_corona_train <- fit_corona_train %>% 
  fabletools::forecast(h = forecast_days) 

# forecasts accuracy
# for evaluating accuracy on forecasts to be provided:
# - a complete dataset that includes the future data and 
# - data used to train the model.

# level = prediction interval in % or NULL
fc_corona_train %>%
  autoplot(corona_tsbl_total) +
  labs(       title = paste(
    country_select, "- Forecast based on regression of previous",
    range_reg_long, "days"),
    subtitle = "Forecast (blue line) vs. Data (black line)") +
  facet_wrap(~ Case_Type, ncol = 2,  scales = "free_y",
             strip.position = "left") +
  scale_x_date(date_labels = "%b %d", date_breaks = "7 days")

```


Forecast w/ CFR {data-navmenu="Forecast"}
=====================================

***
***

Column {data-width=400}
-------------------------------------

### Forecasting with lagged Predictors

The number of confirmed cases is an early predictor of the number of deaths.
The number of today's deaths is already determined by the infections about by 
$\sim19$ days ago or respectively by the confirmed cases about by $\sim11$ days
ago [see Bar Chart - CFR](#cfr).

The country specific case fatality rate (CFR, proportion of deaths from 
confirmed cases) indicates the country specific testing rate and may depend on quality/capacity of hospitals. 

Overall a rough conclusion on the country specific **underreporting rate** 
(lack of diagnostic confirmation; proportion of all infected to confirmed cases)
is feasible if the infection fatality rate (IFR, confiremd cases plus all 
asymptomatic and undiagnosed infections) is assumed to be country independent 
and the IFR is known (bottom of existing estimates $\sim0.56\%$, assumption by 
RKI see [[@RKI2020b]](#bib).

In this case an estimation of the CFR of $0.06$ $(6\%)$ indicates an
underreporting by a by a factor of $\sim10$. 
A CFR of $0.20$ $(20\%)$ indicates an underreporting by a by a factor of $\sim30$.
This corresponds to RKI assumption of a underreporting by a factor of $11-20$ [[@RKI2020a]](#bib). Unfortunately, the IFR or lethality is still far too 
imprecise for concrete conlusions.


In the model paper RKI assumes for the

* Incubation period $\sim5-6$ days - Day of infection day until symptoms are upcoming)
* Hospitalisation $+4$ days  - Admission to the hospital (if needed) after Incubation Period)
* Average period to death $+11$ - if the patient dies, it takes an average of 
$11$ days after admission to the hospital

Depending on the country-specific test frequency (late or early tests), 
the 

*lag_days - time from receipt of the confirmed test result to death, Confirmed to Death, 
is about $11-13$ days.


Note: these methods are also used for example for advertising campaigns. The
campaign impact on sales will be some time beyond the end of the campaign, and 
sales in one month will depend on the advertising expenditure in each of the 
past few months [[see @Hyndman2020]](#bib).


Column {data-width=600}
-------------------------------------

### Daily Confirmed and Death Cases

```{r forecast for selected countries and lags}

# infected_to_confirmed  # infected -> confirmed ~ 9 days,
#                        # Incubation period ~ 5-6 days + testing + get result
#                        # Hospitalisation + 4 days
# infected_to_death      # infected -> death     ~ after 21 days
# lag_x : confirmed_to_death     # ~ 13 days, ~ 21 - 9 days
# case_fatality_rate     # proportion of deaths / number of people diagnosed
# 
#                                                                   (Confirmed)

lag_germany <- 12 # 13
lag_italy <-  12  # 10
lag_spain <- 12   # 11

countries_to_forecast <- c("Germany", "Italy", "Spain")

countries_fc_param <-
  tibble(Country = countries_to_forecast,
       confirmed_to_death = c(lag_germany, lag_italy , lag_spain),
       infected_to_death     = 21) %>% 
       # case_fatality_rate = c(0.08, 0.20, 0.13))
  mutate(infected_to_confirmed = infected_to_death  - confirmed_to_death)

        
```


```{r eval = TRUE}

corona_country_sel <- corona_data %>% 
  filter(Country %in% countries_to_forecast & 
           Date >= last_date - 28) %>%
  ungroup() %>% 
  dplyr::select(Date, Country, Case_Type, Cases)

fc_corona_sel <- fc_corona %>% 
  filter(Country %in% countries_to_forecast &
           Date <= last_date + 8) %>% 
  mutate(Case_Type = case_when(
    Case_Type == "Confirmed" ~ "FC_Confirmed",
    Case_Type == "Deaths" ~ "Exp_growth"))
fc_corona_sel %<>% as_tibble(fc_corona_sel) %>% 
  dplyr::select(Date, Country, Case_Type, Daily_Cases_Mean)

corona_country_sel <- bind_rows(corona_country_sel, fc_corona_sel)
```

```{r Daily Confirmed lagged, fig.width = 5, fig.asp = 1.2}

data <- corona_data %>%  filter(Country %in% countries_to_forecast &
           Date >= last_date - 21)

p <- ggts_conf_deaths_facet(data, y = Daily_Cases_Mean, col = Case_Type) +
      ggtitle("Daily Rolling Mean Cases (past 3 weeks)")
p # ggplotly(p)
```



```{r }

# identify "best" lag_day with lowest AICc 

lag_days <-  max(countries_fc_param$confirmed_to_death)
lag_range <- lag_days + 21
country <- countries_to_forecast[1]


corona_tsbl_lag_range <- corona_tsbl %>% ungroup() %>% group_by(Case_Type) %>% 
  filter(Country %in% countries_to_forecast &
           Date >= last_date - lag_range) %>% 
  dplyr::select(Date, Country, Case_Type, Daily_Cases_Mean) %>% 
  group_by(Country)

```


```{r}
## wide format to get Daily Deaths as function of Daily Confirmed Cases
corona_tsbl_lag_range_wide <- corona_tsbl_lag_range %>%   
  pivot_wider(id_cols = c(Country, Date), 
              names_from = Case_Type, 
              values_from = Daily_Cases_Mean) %>% 
  tsibble::as_tsibble(index = Date, key = c(Country))

```


```{r caluclate lag confirmed country dependent}

lm_term <- c("lag(Confirmed, lag_days - 2)",
             "lag(Confirmed, lag_days - 1)",
             "lag(Confirmed, lag_days)",
             "lag(Confirmed, lag_days + 1)",
             "lag(Confirmed, lag_days + 2)")

country_table <- tibble()
save_plot_fit <- list()

## issue testing ##
for (country in countries_to_forecast) {  
  lag_days <- (countries_fc_param %>% 
                 filter(Country == country))$confirmed_to_death
  # model ~ 0 + => w/o intercept
  fit_best <- corona_tsbl_lag_range_wide %>% 
    filter(Country == country) %>% 
    model(ARIMA(Deaths ~ 0 + pdq(d = 0) + 
                  lag(Confirmed, lag_days - 2) +
                  lag(Confirmed, lag_days - 1) +
                  lag(Confirmed, lag_days) +
                  lag(Confirmed, lag_days + 1) +
                  lag(Confirmed, lag_days + 2)
    ))
  if (country == "Germany") {
    fit_best_germany <- fit_best
  }

  corona_deaths_of_confirmed <- corona_tsbl_lag_range_wide  %>% 
    ungroup() %>%
    new_data(lag_days, keep_all = TRUE)
  
  
  ## plot Daily Deaths plus FC of model(ARIMA(Deaths ~ 0 + lag(Confirmed, lag_days)))
  plot_fit <- fit_best %>%
    forecast(corona_deaths_of_confirmed) %>%
    #  forecast horizon automatically (by new data) fixed to lag-days minus 
    #     model dependency lag_days - 1 & lag_days - 2 => 12days - 2 = 10 days
    autoplot(corona_tsbl_lag_range_wide %>%  
               filter(Date >= last_date - 20)) + 
    labs(y = "Daily Deaths",
         subtitle = 
           paste(country, "w/ avg. Confirmed -> Death:", lag_days, "lag-days"))
  save_plot_fit[[country]] <- plot_fit
  country_table_new <- c(Country = country, 
                         lag_Confirmed = lag_days, 
                         CFR = as.numeric(
                           round(coef(fit_best) %>%  
                                   filter(term %in% term) %>%
                                   summarise(CFR = sum(estimate)), digits = 2))
  )
  country_table <- bind_rows(country_table, country_table_new)
}

plot_deaths_forecast <- 
  save_plot_fit$Germany / save_plot_fit$Italy / save_plot_fit$Spain + 
  plot_annotation(
    title = "Forecast Mean Daily Deaths for next 10 days") +
  plot_layout(guides = 'collect') &
  theme(legend.position='bottom')
plot_deaths_forecast 

```


### Lag days and Case Fatality Rate (CFR)  {data-height=100}

```{r CFR Table - for compare_countries}

title <- paste("Case Fatality Rate in % (CFR, proportion of deaths from confirmed cases)", "lagged by", lag_n, "days; total and for period of past", range_cfr, "days")
knitr::kable(cfr_table %>% filter(Country %in% countries_to_forecast),
             digits = 2, caption = title)



# knitr::kable(country_table,
#              digits = 2, caption =
#                "Lag days and CFR (proportion of deaths from confirmed cases)")


# knitr::kable(coef(fit_best) %>% 
#                group_by(Country) %>% filter(term %in% lm_term) %>%  
#                summarise(CFR = sum(estimate) ), 
#              digits = 2, caption = paste(
#                "Case Fatality Fate in % (CFR, proportion of deaths from confirmed cases)", "lagged by", lag_n, "total and for period of past ", lag_n, "days")
```



Column {data-width=600}
-------------------------------------

### Daily Deaths Forecast depending on lagged Daily Confirmed Cases (ARIMA model)


```{r plot lag confirmed country dependent, fig.width = 5, fig.asp = 1.2}

plot_deaths_forecast

```


### Exampla Germany - White Noise of Forecast Residuals {data-height=150}

Forecast residuals indicate quality of fit with Arima model:


```{r corona ARIMA tsresiduals, fig.width = 5, fig.asp = 0.618}

# `r coef(fit_best)$.model[1]`

fit_best_germany  %>% 
  gg_tsresiduals() +
  labs(title = paste("Germany -  Forecast Residuals w/ Correlogram and Histogram"),
       subtitle = paste("Model: ARIMA w/ lagged predictor; lag_days:", lag_germany))
```

```{r}

```



References {#bib}
=====================================

***
***
  
### Data Source {data-height=400}

**Data Source**

Data files are provided by **Johns Hopkins University** on GitHub  
<https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series>

* Data files:  
    + *time_series_covid19_confirmed_global.csv* 
    + *time_series_covid19_deaths_global*
    + *time_series_covid19_recovered_global.csv*

The data are visualized on their excellent Dashboard  
**Johns Hopkins University Dashboard**  
<https://coronavirus.jhu.edu/map.html>


**Code Source**

Directory with all R Sources is replicated in GitHub repository:  
<https://github.com/WoVollmer/R-TimesSeriesAnalysis/tree/master/Corona-Virus>

Code is based on ideas from <https://rpubs.com/TimoBoll/583802>

### Bibliography

